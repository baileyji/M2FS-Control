REM ISR routines (e.g. ININT) always interrupt thread 0.
REM If a limit caused deceleration at SD rate and a ST 
REM   is issued the deceleration rate is not changed.
REM ST changes the stop code even if an axis is already stopped.
REM It appears that ^a, etc only get pushed onto the stack from the 2nd level down
REM also, it does not appear there is a way to use introspection to determine 
REM what stack depth a function is at
'***************************************************************************
' Initial Configuration
'***************************************************************************
#INIT
ST;MC;MO*

REM Defines
REM None of these should ever need to change and in fact changing WILL cause
REM bizarre and bad behavior!
REM For parameters look lower to the Parameters section.

GESAX=0
FLSINAX=1
FOCAX=2
FESINAX=3
FESELAX=4
LRTLTAX=5
HRTLTAX=6
HRAZAX=7

'Logic States
true=1;false=0

ENONE=0;'All is well
ETIME=1;
EHMERR=3;'HoMeingERRor
EPOTJAM=4;'POTJAMmed
ELIMSWF=5;'LIMitSWitchFail
ELCKERR=6;'LockError
EBADFP=7;'BADFilterPos
EGESPMM=8;'GESPotMotorMismatch
EFAIL=9
ECRAZY=11;'A passed parameter is outside of all sane bounds
ELIMOST=12;' Over shot the limitswitch
EFLTUNSF=13
ELIMSW=14;' Limit switch disallows move
EBADAX=15;'Routine can't operate on specified axis

'Array of threaded execution parameters
DM a[8],b[8],c[8],d[8],e[8],f[8],g[8],h[8],ret[8]
a[0]=0;a[1]=0;a[2]=0;a[3]=0;a[4]=0;a[5]=0;a[6]=0;a[7]=0
b[0]=0;b[1]=0;b[2]=0;b[3]=0;b[4]=0;b[5]=0;b[6]=0;b[7]=0
c[0]=0;c[1]=0;c[2]=0;c[3]=0;c[4]=0;c[5]=0;c[6]=0;c[7]=0
d[0]=0;d[1]=0;d[2]=0;d[3]=0;d[4]=0;d[5]=0;d[6]=0;d[7]=0
e[0]=0;e[1]=0;e[2]=0;e[3]=0;e[4]=0;e[5]=0;e[6]=0;e[7]=0
f[0]=0;f[1]=0;f[2]=0;f[3]=0;f[4]=0;f[5]=0;f[6]=0;f[7]=0
g[0]=0;g[1]=0;g[2]=0;g[3]=0;g[4]=0;g[5]=0;g[6]=0;g[7]=0
h[0]=0;h[1]=0;h[2]=0;h[3]=0;h[4]=0;h[5]=0;h[6]=0;h[7]=0
ret[0]=0;ret[1]=0;ret[2]=0;ret[3]=0;ret[4]=0;ret[5]=0;ret[6]=0;ret[7]=0

'Delta of last move, maintained by #BACKLSH
DM ldelta[8]
ldelta[GESAX]=0;ldelta[FLSINAX]=0;ldelta[FOCAX]=0;ldelta[FESINAX]=0
ldelta[FESELAX]=0;ldelta[LRTLTAX]=0;ldelta[HRTLTAX]=0;ldelta[HRAZAX]=0

'Possible Axis positions
out=0
in=1
moving=2
intermd=3
unknown=4
lores=5
hires=6
settle=7
lrswap=8
filterp1=9;'rest of filter position enums are set programatically
REM Aditional position defines must start at filterld+1
filterp2=filterp1+1;filterp3=filterp1+2;filterp4=filterp1+3;filterp5=filterp1+4
filterp6=filterp1+5;filterp7=filterp1+6;filterp8=filterp1+7;filterld=filterp1+8

'Pot monitoring
potjam=1
'Value must be set to 1 atomically when zeroing the position of an encoded axis
GESPM=0;FESELPM=1;DM rstpm[2];rstpm[GESPM]=false;rstpm[FESELPM]=false

nearfilt=0;' nearest filter to current position, determined by QUFEL

'Whether or not the axis is calibrated
DM axiscal[8]
axiscal[GESAX]=false;axiscal[FLSINAX]=false;axiscal[FOCAX]=false
axiscal[FESINAX]=false;axiscal[FESELAX]=false;axiscal[LRTLTAX]=false
axiscal[HRTLTAX]=false;axiscal[HRAZAX]=false

'Last error state of the axis
DM axiserr[8]
axiserr[GESAX]=ENONE;axiserr[FLSINAX]=ENONE;axiserr[FOCAX]=ENONE
axiserr[FESINAX]=ENONE;axiserr[FESELAX]=ENONE;axiserr[LRTLTAX]=ENONE
axiserr[HRTLTAX]=ENONE;axiserr[HRAZAX]=ENONE

'Analog Filter Arrays
DM analogp[8]
DM anapcln[8];'-1 if no motion has occured within filter window
~a=GESAX;gesanap=_TP~a;analogp[GESAX]=gesanap
~a=FOCAX;focanap=_TP~a;analogp[FOCAX]=focanap
~a=FESELAX;felanap=_TP~a;analogp[FESELAX]=felanap
anapcln[GESAX]=-1;anapcln[FOCAX]=-1;anapcln[FESELAX]=-1



REM Parameters
REM Absolutly do not consider a value final unless it has a comment!
REM  (or the instrument is on the telescope and in use, then Mea Culpa -JB)


'Analog Position Filtering
ANAMAFSZ=1000;'Filter sample size (filter should run at 1ms intervals)


DM axaccel[8];'Generic Acceleration rate
axaccel[GESAX]=100000
axaccel[FLSINAX]=256000
axaccel[FOCAX]=100000
axaccel[FESINAX]=256000
axaccel[FESELAX]=256000
axaccel[LRTLTAX]=100000
axaccel[HRTLTAX]=100000
axaccel[HRAZAX]=100000

DM axdecel[8];'Generic Deceleration rate
axdecel[GESAX]=100000
axdecel[FLSINAX]=256000
axdecel[FOCAX]=100000
axdecel[FESINAX]=256000
axdecel[FESELAX]=256000
axdecel[LRTLTAX]=190000
axdecel[HRTLTAX]=160000;'5/6 * 15000um/s^2/0.078um/us=160256
axdecel[HRAZAX]=160000;'5/6 * 15000um/s^2/0.078um/us=160256

DM axlmspd[8];'limit speed (speed used when intentionally moving to a limit)
axlmspd[GESAX]=6400
axlmspd[FLSINAX]=1024
axlmspd[FOCAX]=6400;'unused
axlmspd[FESINAX]=1024
axlmspd[FESELAX]=6400
axlmspd[LRTLTAX]=6400;'unused
axlmspd[HRTLTAX]=6400
axlmspd[HRAZAX]=6400
REM NB The PI actuators advise no greater than 10% max speed
REM    when approaching limits.

DM axhmspd[8];'homing speed, used when returning to home after overshoot
axhmspd[GESAX]=256
axhmspd[FLSINAX]=256
axhmspd[FOCAX]=256
axhmspd[FESINAX]=256
axhmspd[FESELAX]=256
axhmspd[LRTLTAX]=256
axhmspd[HRTLTAX]=256
axhmspd[HRAZAX]=256

DM axspd[8];'Generic travel speed
axspd[GESAX]=7000;'16215;'seems ok
axspd[FLSINAX]=1024
axspd[FOCAX]=7000;'15000;'seems ok
axspd[FESINAX]=1024
axspd[FESELAX]=7000
axspd[LRTLTAX]=10000;'seems ok (w/o grating) Max per DS: 30091
axspd[HRTLTAX]=10000;'Max per DS: 5/6*5000um/s/0.078um/us=53418
axspd[HRAZAX]=10000;'Max per DS: 5/6*5000um/s/0.078um/us=53418

DM axmaxp[8];'Max possible position (steps, 16x microstepping)
axmaxp[GESAX]=288112;'Actual value slightly greater if overshooting limits
axmaxp[FLSINAX]=6447;'Determined experimentally
axmaxp[FOCAX]=16*200*180;'Infinite, about 1 revolution
axmaxp[FESINAX]=9413;'Determined experimentally, B Side
axmaxp[FESELAX]=210000;'Determined experimentally, B Side
axmaxp[LRTLTAX]=1126400; '1 revolution
axmaxp[HRTLTAX]=128205/2;'10mm
axmaxp[HRAZAX]=128205/2;'10mm

DM axminp[8];'Max possible position (steps, 16x microstepping)
axminp[GESAX]=0
axminp[FLSINAX]=0
axminp[FOCAX]=0
axminp[FESINAX]=0
axminp[FESELAX]=0
axminp[LRTLTAX]=0
axminp[HRTLTAX]=-128205/2;'10mm
axminp[HRAZAX]=-128205/2;'10mm

DM bcklsh[8];'backlash in steps, for reference
bcklsh[GESAX]=77;'76.2 microns
bcklsh[FLSINAX]=15;'Determined experimentally
bcklsh[FOCAX]=18;'880 microradians (estimate based on LRTLT stage)
bcklsh[FESINAX]=55;' ABOUT 52-58
bcklsh[FESELAX]=15;'Determined experimentally
bcklsh[LRTLTAX]=34;'200 microradians (34.48 usteps)
bcklsh[HRTLTAX]=128;'10 microns (128.2 usteps)
bcklsh[HRAZAX]=128;'10 microns (128.2 usteps)

DM mininc[8];'minimum incremental motion
mininc[GESAX]=0
mininc[FLSINAX]=0
mininc[FOCAX]=0
mininc[FESINAX]=0
mininc[FESELAX]=0;'<20 by touch
mininc[LRTLTAX]=4;'Per DS: 21 microradians = 3.62 us => 4 usteps = 23.2 urad
mininc[HRTLTAX]=13;'microsteps, 1 micron
mininc[HRAZAX]=13;'microsteps, 1 micron

'Unused, comented as short of array space
'DM dperus[8];'delta per microstep
'dperus[GESAX]=.992;'microns per microstep
'dperus[FLSINAX]=0
'dperus[FOCAX]=49.087;'microradians per microstep
'dperus[FESINAX]=0
'dperus[FESELAX]=0
'dperus[LRTLTAX]=5.8;'microradians per microstep
'dperus[HRTLTAX]=0.078;'microns per microstep
'dperus[HRAZAX]=0.078;'microns per microstep

'Encoder value near a limit, unused on unencoded. Value strictly > -limit
DM encnlim[8]
' GES reading of 161 while on -lim, hardstop at 49. 
encnlim[GESAX]=240
encnlim[FESELAX]=0
'Value slightly before 4096-to-0 rollover
'unknown, NEED testing TODO (or remove if we aren't going to use CALFOC
encnlim[FOCAX]=3800

'FOC related defines
focentol=5;' Encoder tolerance of a desired pot position TODO: DETERMINE

'GES Related Defines
geshrp=7400;'(steps) Position of HiRes mode from calibrated 0 TODO: finalize
geslrp=265000;'(steps) Position of LoRes mode from calibrated 0 TODO: finalize
gesgsp=1393;' GES Grating Swap position relative to calibrated 0 TODO: finalize
geshrep=285; 'GES HR encoder nominal position TODO: finalize
geslrep=3798; 'GES LR encoder nominal position ROUGH GUESS TODO: finalize
gesgsep=1397;' GES Grating Swap encoder nominal position TODO: finalize
'GES encoder nominal position tolerance 
gesenct=7;'1st GUESS:0.5mm/(300mm/4096) TODO: finalize

'HiRes Alt & Az defines
HRTLTLK=true;HRAZLK=true;'Start assuming locked
LCKVOLT=2 ;'Determined empirically, > => locked 

'LoRes Tilt defines
lrthmos=6400;'Amount to overshoot home before creeping back (TODO:refine guess)
lrtinpt=9;'  Digital in corresponding to the LoRes origin sensor
lrtinhx=$9;'  Digital in corresponding to the LoRes origin sensor in hex
lrtathm=1 ;'  value of origin sensor (via @IN) when at home
lrhomng=false;' Is the axis trying to home at present
lrswapp=-423000;' step position for lr grating swap

'Filter related defines
nfilt=8;' Number of filter slots

'NB Elevator nominally travels .1" per rev (3200 steps) 

'FES Elevator nominal filter positions in encoder counts
^a=nfilt+1;DM felencp[^a]

REM Red side 12/15/12
felencp[0]=79.5;'Valid +/-9.5
felencp[1]=383.5;'Valid +/-4.5
felencp[2]=667.5;'Valid +/-5.5
felencp[3]=960;'Valid +/-8
felencp[4]=1247;'Valid +/-5
felencp[5]=1531;'Valid +/-4
felencp[6]=1808;'Valid +/-5
felencp[7]=2108.5;'Valid +/-6.5
felencp[8]=3789;'Valid +/-40
'Elevator tolerance (+/-) in encoder counts about filter position
feselrg=2.5
'Encoder pos above which it is always safe to move the inserter
allsafep=3749
'55.4 steps/cnt
'57.76 cnts/rev

REM Blue side 12/15/12
REM felencp[0]=113.5;'Valid +/-12.5
REM felencp[1]=416;'Valid +/-8
REM felencp[2]=704;'Valid +/-13
REM felencp[3]=991.5;'Valid +/-12.5
REM felencp[4]=1276;'Valid +/-12
REM felencp[5]=1560.5;'Valid +/-10.5
REM felencp[6]=1846;'Valid +/-7
REM felencp[7]=2131.5;'Valid +/-7.5
REM felencp[8]=3790.5;'Valid +/-72.5
REM 'Elevator tolerance (+/-) in encoder counts about filter position
REM feselrg=5.5
REM 'Encoder pos above which it is always safe to move the inserter
REM allsafep=3718
REM '54.57 steps/cnt
REM '58.64 cnts/rev

'Flag to indicate move in progress
' without this there is a race condition with a filter query
' while the elevator has reaced position but the inserter hasn't started that
' would result in NONE being reported
filmove=0

'FESIN related defines
fesinsp=9000 ;'The inserted position in steps of the FESIN arm
fesremp=1;'The removed position in steps of the FESIN arm, must be >0

'FLS related defines
flsbkof=25;'The steps to backoff after inserting


EN


'***************************************************************************
' Galil hardware config
'  Do not use any parameters in here, nothing is defined when this is called
'***************************************************************************
#M2FSCFG
ST;MC;MO*
'Set motor type, must be -2 or -2.5 per manual
MT -2.5,-2.5,-2.5,-2,-2,-2,-2.5,-2.5
KS*=1;'       Set step smoothing to Galil-recommended value, see AN#2446
AG 3,1,3,1,3,0,0,0;'              Set motor gain values
AQ1,4;AQ3,4;AQ5,4;AQ7,4;AQ8,4;'  GES,FOC,FESEL,HRTLT,HRAZ analog inputs: 0-10V
AF 1,,1,,1;'		Configure GES, FES, & FOC for analog feedback
YA 16,16,16,16,16,16,16,16;'Set stepping mode resolutions
YB 200,200,200,200,200,400,400,400;'Set stepper motor steps/revolution
LDE=3;'No limits on filter elevator
'Encoder counts/rev
'GES Nominally 44.7. GER R measured to be about 42.3
'FESEL measured to be 60.76 counts/rev on B side
'FESEL measured to be 57.76 (R) & 58.64 (B) counts/rev (12/15/12)
YC 42,,26,,58
'No built-in position error detection for steppers 	
ER*=-1			
'Configure: Limits active high, Home high -> go backward (retract)
'  to go home (needed by M228), Latch (Don't care), 
'  DI 4-7,12-15 axis specific aborts, Abort doesn't kill program
CN 1,-1,,1,1
CI 0
EN


'***************************************************************************
' Starutp Routine
'***************************************************************************
#AUTO
HX1;HX2;HX3;HX4;HX5;HX6;HX7;ST;MC;MO*
m2fsver=.1;bootup1=1
JS#M2FSCFG
JS#INIT

'Set acceleration defaults
AC axaccel[0],axaccel[1],axaccel[2],axaccel[3]
AC ,,,,axaccel[4],axaccel[5],axaccel[6],axaccel[7]

'Set deceleration defaults
DC axdecel[0],axdecel[1],axdecel[2],axdecel[3]
DC ,,,,axdecel[4],axdecel[5],axdecel[6],axdecel[7]

'Set limit switch triggered deceleration
SD axdecel[0],axdecel[1],axdecel[2],axdecel[3]
SD ,,,,axdecel[4],axdecel[5],axdecel[6],axdecel[7]

'Set homing velocity defaults
HV axhmspd[0],axhmspd[1],axhmspd[2],axhmspd[3]
HV ,,,,axhmspd[4],axhmspd[5],axhmspd[6],axhmspd[7]

'Set speed defaults
SP axspd[0],axspd[1],axspd[2],axspd[3]
SP ,,,,axspd[4],axspd[5],axspd[6],axspd[7]

'Start the analog filter
XQ #ANAMAF,1
'Start the motor monitor to ensure they don't get left on
momon=1
XQ #MOMONI,2

'Query the Filter elevator position to initialize nearfilt
JS#QUFELP

'Idle forever
#AUTO1
' Monitor the axis locks for the HiRes stage
IF(@AN[7] > LCKVOLT);HRTLTLK=true;ELSE;HRTLTLK=false;ENDIF
IF(@AN[8] > LCKVOLT);HRAZLK=true;ELSE;HRAZLK=false;ENDIF
'Ensure the motor monitor routine is running
IF(_HX2=0);XQ#MOMONI,2;ENDIF
WT 1000;JP#AUTO1
EN


'***************************************************************************
' MOtor MONitor 
'  Turn motors off if none of the motion threads are running
' For internal use only
'***************************************************************************
#MOMONI
IF(((((momon=1)&(_HX3=0))&((_HX4=0)&(_HX5=0)))&(_HX6=0)));MO*;ENDIF
WT 1000;JP#MOMONI
EN


'***************************************************************************
' Shutdown Routine RUN ON THREAD 3
'***************************************************************************
#SHTDWN
HX4;HX5;HX6;ST*;MC;MO*
a[3]=9;XQ#PICKFIL,4
a[4]=0;XQ#SETLRTL,5
JP#IDLE
EN

'***************************************************************************
' Motion Complete Timeout Routine
'TODO test with ultrishort timeout & long move, see if ST is needed b4 MO
'ST resets the stopcode
'***************************************************************************
#MCTIME
IF(_SCA=99);MOA;axiserr[0]=ETIME;STA;ENDIF
IF(_SCB=99);MOB;axiserr[1]=ETIME;STB;ENDIF
IF(_SCC=99);MOC;axiserr[2]=ETIME;STC;ENDIF
IF(_SCD=99);MOD;axiserr[3]=ETIME;STD;ENDIF
IF(_SCE=99);MOE;axiserr[4]=ETIME;STE;ENDIF
IF(_SCF=99);MOF;axiserr[5]=ETIME;STG;ENDIF
IF(_SCG=99);MOG;axiserr[6]=ETIME;STG;ENDIF
IF(_SCH=99);MOH;axiserr[7]=ETIME;STH;ENDIF
EN 1


'***************************************************************************
' CALibrate LoRes Tilt
' Calibrate the LoRes tilt
' Does not turn axis off if sucessful
' Returns ENONE iff sucessful
' Errors: ELRTSEN - home sensor failed
' assumes LoRes Axis is "F"
'***************************************************************************
#CALLRT
'Stack and XQ fancy footwork
JS#ZS;IF (_JS<1);JS#CALLRT;^h=_JS;ed4=_ED4;ret[ed4]=_JS;ELSE
'Axis F, Hope Success
^a=LRTLTAX;^h=ENONE;axiserr[^a]=ENONE
'Find home sensor if not there already
IF (@IN[lrtinpt]<>lrtathm)
II ,,lrtinhx,lrtinhx;'Trip on @IN[lrtinpt] goes to 1
lrhomng=true
'Do a relative move -1.1 revolutions
~a=^a;^b=-1.10*(axmaxp[^a]-axminp[^a])
~a=^a; AC~a=axaccel[^a]; DC~a=axdecel[^a]; SP~a=axspd[^a];PR~a=^b;SH~a; BG~a
' wait till stopped (input interrupt stopped us) or get to position
#CALLRT1;WT 500;JP#CALLRT1, (_SCF=0);~a=^a;MC~a
'If not stopped by ST in interrupt routine turn off and fail.
IF (_SCF<>4);~a=^a;MO~a;^h=EHMERR
ENDIF;ENDIF
'If all is well
IF (^h=ENONE)
'Continue on to move off the home sensor
^b=-lrthmos
~a=^a;AC~a=axaccel[^a];DC~a=axdecel[^a];SP~a=axspd[^a];PR~a=^b;SH~a;BG~a;MC~a
'Move to home sensor
lrhomng=true
^b=(1.1*lrthmos)+bcklsh[^a] 
~a=^a; DC~a=axdecel[^a]; SP~a=axhmspd[^a]; PR~a=^b;SH~a; BG~a
' wait till stopped (input interrupt stopped us) or get to position
#CALLRT2;WT 500;JP#CALLRT2, (_SCF=0);~a=^a;MC~a
'If not stopped by ST in interrupt routine turn off and fail
' else Define the new position as home
IF (_SCF<>4);~a=^a;MO~a;^h=EHMERR
ELSE;~a=^a;DP~a=0;axiscal[^a]=true;ldelta[^a]=^b
ENDIF
ENDIF
' Turn off input interrupt and store status
II 0,,,;axiserr[^a]=^h
ENDIF
EN ,,^h


'***************************************************************************
' INput change INTerrupt
' If LoRes Tilt is homing and the input is triggered then halt the motion and
'  SHF (this should mean that a MC trippoint on the axis is cleared.)
'  TODO call galil re this
'***************************************************************************
#ININT
IF ((lrhomng=true)&(@IN[lrtinpt]=lrtathm))
REM DCF=axdecel[5] This command is reported as not valid while running yet I can 
REM  execute it over serial w/o any problem TODO: CALL GALIL 
REM STF;SHF;lrhomng=false
STF;lrhomng=false;ENDIF
RI


'***************************************************************************
' Get LoRes TiLt position
'***************************************************************************
#GETLRTL
'Stack and XQ fancy footwork
JS#ZS;IF (_JS<1);JS#GETLRTL;ed4=_ED4;ret[ed4]=0;ELSE
^a=LRTLTAX
'Error status
IF(axiserr[^a]<>ENONE);JS#ERRMSG(^a,axiserr[^a])
'Move in progress
ELSE; ~a=^a;IF(_TS~a & $80);MG "GETLRTL: MOVING"
'Not calibrated
ELSE; IF(axiscal[^a]<>true);MG "GETLRTL: UNCALIBRATED"
'report position
ELSE; ~a=^a; MG "GETLRTL:",_TD~a
ENDIF;ENDIF;ENDIF;ENDIF
EN


'***************************************************************************
' Set LoRes TiLt(angle)
' Set the lo res tilt angle
'***************************************************************************
#SETLRTL
'Stack and XQ fancy footwork
JS#ZS;IF (_JS<1);ed4=_ED4;JS#SETLRTL(a[ed4]);^h=_JS;ed4=_ED4;ret[ed4]=_JS;ELSE
^b=^a
^a=LRTLTAX;^h=ENONE;axiserr[^a]=ENONE
'Calibrate if not
IF (axiscal[^a]<>true);JS#CALLRT;^h=_JS;ENDIF
'If we are good to go, MOVE!
IF(^h=ENONE);JS#FANCYMV(^a,^b);~a=^a;MC~a;~a=^a;MO~a;ENDIF
'Store status
axiserr[^a]=^h
ENDIF
EN,,^h


'***************************************************************************
' Get HiRes TiLt position
'***************************************************************************
#GETHRTL
JS#ZS;IF (_JS<1);JS#GETHRTL;ed4=_ED4;ret[ed4]=0;ELSE
^a=HRTLTAX
'Error status
IF(axiserr[^a]<>ENONE);JS#ERRMSG(^a,axiserr[^a])
'Move in progress
ELSE; ~a=^a;IF(_TS~a & $80);MG "GETHRTL: MOVING"
'Not calibrated
ELSE; IF(axiscal[^a]<>true);MG "GETHRTL: UNCALIBRATED"
'report position
ELSE; ~a=^a; MG "GETHRTL:",_TD~a
ENDIF;ENDIF;ENDIF;ENDIF
EN


'***************************************************************************
' Set HiRes TiLt(steps)
' Set the hi res tilt angle
'***************************************************************************
#SETHRTL
'Stack and XQ fancy footwork
JS#ZS;IF(_JS<1);ed4=_ED4;JS#SETHRTL(a[ed4]);^h=_JS;ed4=_ED4;ret[ed4]=_JS;ELSE
^b=^a
^a=HRTLTAX;^h=ENONE;axiserr[^a]=ENONE
'Make sure the axis isn't locked
IF(HRTLTLK=true);^h=ELCKERR;ENDIF
'If we are good to go, make sure commanded position is sane
IF(^h=ENONE);JS#SANEPOS(^a,^b);IF(_JS<>true);^h=ECRAZY;ENDIF
'If we are good to go, but not calibrated, calibrate
IF ((^h=ENONE)&(axiscal[^a]<>true));JS#CALHMAX(^a);^h=_JS;ENDIF
'If we are good to go, MOVE!
IF(^h=ENONE);JS#FANCYMV(^a,^b);^h=_JS;~a=^a;MC~a
~a=^a;IF((SC~a=2)|(SC~a=3));^h=ELIMSW;ENDIF;MO~a;ENDIF
ENDIF
'Store status
axiserr[^a]=^h
ENDIF
EN,,^h


'***************************************************************************
' Calibrate HiRes Azimuth position
'***************************************************************************
#CALHRAZ;JS#CALHMAX(HRAZAX);ed4=_ED4;ret[ed4]=_JS;EN


'***************************************************************************
' Get HiRes AZimuth position
'***************************************************************************
#GETHRAZ
JS#ZS;IF(_JS<1);JS#GETHRAZ;ed4=_ED4;ret[ed4]=0;ELSE
^a=HRAZAX
'Error status
IF(axiserr[^a]<>ENONE);JS#ERRMSG(^a,axiserr[^a])
'Move in progress
ELSE; ~a=^a;IF(_TS~a & $80);MG "GETHRAZ: MOVING"
'Not calibrated
ELSE; IF(axiscal[^a]<>true);MG "GETHRAZ: UNCALIBRATED"
'report position
ELSE;~a=^a; MG "GETHRAZ:",_TD~a
ENDIF;ENDIF;ENDIF;ENDIF
EN


'***************************************************************************
' Set HiRes AZimuth(steps)
' Set the hi res azimuth position
'***************************************************************************
#SETHRAZ
'Stack and XQ fancy footwork
JS#ZS;IF(_JS<1);ed4=_ED4;JS#SETHRAZ(a[ed4]);^h=_JS;ed4=_ED4;ret[ed4]=_JS;ELSE
^b=^a
^a=HRAZAX;^h=ENONE;axiserr[^a]=ENONE
'Make sure the axis isn't locked
IF(HRAZLK=true);^h=ELCKERR;ENDIF
'If we are good to go, make sure commanded position is sane
IF(^h=0);JS#SANEPOS(^a,^b);IF(_JS<>true);^h=ECRAZY;ENDIF
'If we are good to go, but not calibrated, calibrate
IF ((^h=0)&(axiscal[^a]<>true));JS#CALHMAX(^a);^h=_JS;ENDIF
'If we are good to go, MOVE!
IF(^h=0);JS#FANCYMV(^a,^b);^h=_JS;~a=^a;MC~a
~a=^a;IF((SC~a=2)|(SC~a=3));^h=ELIMSW;ENDIF;MO~a;ENDIF
ENDIF
'Store status
axiserr[^a]=^h
ENDIF
EN,,^h


'***************************************************************************
' Calibrate the GES Stage
' return value is in ret
'***************************************************************************
#CALGES;JS#CALENAX(GESAX);ed4=_ED4;ret[ed4]=_JS;EN


'***************************************************************************
' QUery GES Position (simple, ignore analog encoder)
' returns hires, lores, unknown, intermd
' TODO sort out behavior for case where motor and pot disagree
'***************************************************************************
#QUGESP2
JS#ZS;IF(_JS<1);JS#QUGESP2;^h=_JS;ed4=_ED4;ret[ed4]=^h;ELSE
^a=GESAX;~a=^a;^g=_TD~a
~a=^a;IF((_TS~a & $80)|(anapcln[^a]<>-1));^h=moving
ELSE;IF(axiscal[^a]<>true);^h=unknown
ELSE;IF(^g=geslrp);^h=lores
ELSE;IF(^g=geshrp);^h=hires
ELSE;IF(^g=gesgsp);^h=lrswap
ELSE;^h=intermd
ENDIF;ENDIF;ENDIF;ENDIF;ENDIF;ENDIF
EN,,^h


'***************************************************************************
' Get GES (simple, ignore analog encoder)
' Return the GES position
'***************************************************************************
#GETGES2
JS#ZS;IF(_JS<1);JS#GETGES2;ed4=_ED4;ret[ed4]=0;ELSE
^a=GESAX
'Determine status
~a=^a;IF (_TS~a & $80);^h=moving
ELSE;IF(anapcln[^a]<>-1);^h=moving;'settle
ELSE;IF(axiscal[^a]<>true);^h=unknown
ELSE
REM ^g step position
~a=^a;^g=_TD~a
IF (^g=geslrp);^h=lores
ELSE;IF (^g=geshrp);^h=hires
ELSE;IF (^g=gesgsp);^h=lrswap
ELSE;^h=intermd
ENDIF;ENDIF;ENDIF;ENDIF;ENDIF;ENDIF
'Report status
IF(axiserr[^a]<>ENONE);JS#ERRMSG(^a,axiserr[^a])
ELSE
IF(^h=unknown);MG "GETGES: UNCALIBRATED";ENDIF
IF(^h=moving);~a=^a;MG "GETGES: MOVING",_TP~a,_TD~a;ENDIF
IF(^h=lores);~a=^a;MG "GETGES: LORES",gesanap,_TD~a;ENDIF
IF(^h=hires);~a=^a;MG "GETGES: HIRES",gesanap,_TD~a;ENDIF
IF(^h=lrswap);~a=^a;MG "GETGES: LRSWAP",gesanap,_TD~a;ENDIF
IF(^h=intermd);~a=^a;MG "GETGES: INTERMEDIATE",gesanap,_TD~a;ENDIF
ENDIF;ENDIF
EN


'***************************************************************************
' LoRes grating swap
'***************************************************************************
#LRSWAP
'Stack and XQ fancy footwork
JS#ZS;IF(_JS<1);JS#LRSWAP;^h=_JS;ed4=_ED4;ret[ed4]=_JS;ELSE
^h=ENONE
^a=LRTLTAX;axiserr[^a]=ENONE
'Calibrate LRTLT if needed
IF (axiscal[^a]<>true);JS#CALLRT;^h=_JS;ENDIF
axiserr[^a]=^h
'Calibrate GES if needed
^a=GESAX;axiserr[^a]=ENONE
IF(axiscal[^a]<>true);JS#CALENAX(^a);^h=(^h | _JS);ENDIF
axiserr[^a]=_JS
'If we are good to go, MOVE!
IF(^h=ENONE)
JS#FANCYMV(LRTLTAX,lrswapp);JS#FANCYMV(GESAX,gesgsp);^h=_JS
^a=LRTLTAX;~a=^a;MC~a;~a=^a;MO~a
^a=GESAX;~a=^a;MC~a;~a=^a;MO~a
'Verify GES in an acceptable position
JS#QUGESP2;IF (_JS<>lrswap);^h=EFAIL;axiserr[GESAX]=EFAIL;ENDIF
ENDIF
ENDIF
EN,,^h


'***************************************************************************
' HIgh RESolution mode
'***************************************************************************
#HIRES
'Stack and XQ fancy footwork
JS#ZS;IF (_JS<1);JS#HIRES;^h=_JS;ed4=_ED4;ret[ed4]=_JS;ELSE
^a=GESAX;^h=ENONE;axiserr[^a]=ENONE
'Calibrate if needed
IF(axiscal[^a]<>true);JS#CALENAX(^a);^h=_JS;ENDIF
'If all is well start moving to position
IF(^h=ENONE);JS#FANCYMV(^a,geshrp);^h=_JS;~a=^a;MC~a;~a=^a;MO~a
'Verify we are in an acceptable position
JS#QUGESP2;IF (_JS<>hires);^h=EFAIL;ENDIF
ENDIF
axiserr[^a]=^h;'Store status
ENDIF
EN,,^h


'***************************************************************************
' LOw RESolution mode
'***************************************************************************
#LORES
'Stack and XQ fancy footwork
JS#ZS;IF (_JS<1);JS#LORES;^h=_JS;ed4=_ED4;ret[ed4]=_JS;ELSE
^a=GESAX;^h=ENONE;axiserr[^a]=ENONE
'Calibrate if needed
IF(axiscal[^a]<>true);JS#CALENAX(^a);^h=_JS;ENDIF
'If all is well start moving to position
IF(^h=ENONE);JS#FANCYMV(^a,geslrp);^h=_JS;~a=^a;MC~a;~a=^a;MO~a
'Verify we are in an acceptable position
JS#QUGESP2;IF(_JS<>lores);^h=EFAIL;ENDIF
ENDIF
axiserr[^a]=^h;'Store status
ENDIF
EN,,^h


'***************************************************************************
' Get Focus Position
' Does not wait for analog value to stabilize
'***************************************************************************
#GETFOC
'Stack and XQ fancy footwork
JS#ZS;IF(_JS<1);JS#GETFOC;ed4=_ED4;ret[ed4]=0;ELSE
^a=FOCAX
'Error status
IF(axiserr[^a]<>ENONE);JS#ERRMSG(^a,axiserr[^a])
'Move in progress
ELSE; ~a=^a;IF((_TS~a & $80)|(anapcln[^a]<>-1))
~a=^a;MG "GETFOC: MOVING",focanap,_TD~a
'Report position
ELSE;
'Make doubly sure the position is stable
JS#WAITAMF(^a)
~a=^a; MG "GETFOC:",focanap,_TD~a
ENDIF;ENDIF;ENDIF
EN


'***************************************************************************
' Set FOC Position(Encoder position)
'***************************************************************************
#SETFOC
'Stack and XQ fancy footwork
JS#ZS;IF(_JS<1);ed4=_ED4;JS#SETFOC(a[ed4]);ed4=_ED4;ret[ed4]=0;ELSE
^b=^a
^a=FOCAX
'Wait for filtered analog position to be clean
JS#WAITAMF(^a)
^c=^b-focanap
JS#ENC2STP(^a,^c);~a=^a;^c=_TD~a+_JS
~a=^a;JS#FANCYMV(^a,^c);~a=^a;MC~a;~a=^a;MO~a
'Rince lather repeat x1 a few times, PID loop would be "proper"
JS#WAITAMF(^a)
^c=^b-focanap
IF(@ABS[^c]>focentol)
JS#ENC2STP(^a,^c);~a=^a;^c=_TD~a+_JS
~a=^a;JS#FANCYMV(^a,^c);~a=^a;MC~a;~a=^a;MO~a
'Rince lather repeat x2
JS#WAITAMF(^a)
^c=^b-focanap
IF(@ABS[^c]>focentol)
JS#ENC2STP(^a,^c);~a=^a;^c=_TD~a+_JS
~a=^a;JS#FANCYMV(^a,^c);~a=^a;MC~a;~a=^a;MO~a
ENDIF;ENDIF
ENDIF
EN


'***************************************************************************
' GET FES Iserter status
' responds "IN" "OUT" "UNKNOWN" "INTERMEDIATE", "MOVING"
'***************************************************************************
#GETFESI
'Stack and XQ fancy footwork
JS#ZS;IF(_JS<1);JS#GETFESI;ed4=_ED4;ret[ed4]=0;ELSE
^a=FESINAX
'Error status
IF(axiserr[^a]<>ENONE);JS#ERRMSG(^a,axiserr[^a])
ELSE
'Report position
^a=unknown
IF ((_LFD=0)&(_LRD=1));^a=in;ENDIF
IF ((_LFD=1)&(_LRD=0));^a=out;ENDIF
IF (_TSD & $80); ^a=moving;ENDIF
IF (^a=out);MG "GETFESI: OUT";ENDIF
IF (^a=moving);MG "GETFESI: MOVING";ENDIF
IF (^a=in);MG "GETFESI: IN";ENDIF
IF (^a=intermd);MG "GETFESI: INTERMEDIATE";ENDIF
IF (^a=unknown);MG "GETFESI: UNKNOWN";ENDIF
ENDIF;ENDIF
EN


'***************************************************************************
' INsert FES INserter arm
'***************************************************************************
#INFESIN
'Stack and XQ fancy footwork
JS#ZS;IF (_JS<1);JS#INFESIN;^h=_JS;ed4=_ED4;ret[ed4]=_JS;ELSE
^h=ENONE;^a=FESINAX;axiserr[^a]=ENONE
IF(_LFD=1);' If not inserted
'Make sure the FESEL is in a safe position to remove filter
JS#FESELSF;^h=_JS
IF(^h=ENONE);'insert the FESIN if all is well
JS#MOV2LIM(^a, axaccel[^a], axdecel[^a], axlmspd[^a]);^h=_JS
REM Check error cases
IF (^h=ENONE)
IF ((_LFD=1)|(_LRD=0));^h=ELIMSWF;ENDIF
ENDIF
~a=^a;MC~a;~a=^a;MO~a
ENDIF
ELSE
IF(_LRD=0);^h=ELIMSWF
ENDIF
ENDIF
axiserr[^a]=^h
ENDIF
EN,,^h


'***************************************************************************
' ReMove FES INserter arm
'***************************************************************************
#RMFESIN
'Stack and XQ fancy footwork
JS#ZS;IF (_JS<1);JS#RMFESIN;^h=_JS;ed4=_ED4;ret[ed4]=_JS;ELSE
^h=ENONE;^a=FESINAX;axiserr[^a]=ENONE
IF(_LRD=1);' If not retracted
'Make sure the FESEL is in a safe position to remove filter
JS#FESELSF;^h=_JS
IF(^h=ENONE);'Remove the FESIN if all is well
JS#MOV2LIM(^a, axaccel[^a], axdecel[^a], -axlmspd[^a]);^h=_JS
IF ((_LFD=1)&(_LRD=0)&(^h=ENONE))
'Move to the removed idle position
~a=^a;DP~a=0;JS#FANCYMV(^a,fesremp);~a=^a;MC~a
~a=^a;IF(_SC~a<>1);^h=EFAIL;ENDIF
~a=^a;MO~a
ELSE
^h=ELIMSWF;~a=^a;MC~a;~a=^a;MO~a
ENDIF
ENDIF
ELSE
IF(_LFD=0);^h=ELIMSWF
ENDIF
ENDIF
axiserr[^a]=^h
ENDIF
EN,,^h


'***************************************************************************
' FES ELevator SaFe
' Returns 0 if the elevator is in a safe position for the 
'  FESIN arm to move
' Cases:
'   caddy is above inserter or within tolerance of a filter position: return 0
'   caddy is in front of inserter, but not within tolerance of filter position
'    if the inserter position is == fesremp
'      nudge to the nearest filter
'      if within tolerance return true
'    fail
' If the elevator isn't is a safe position it attempts to move it to a safe
' position
'***************************************************************************
#FESELSF
'Stack and XQ fancy footwork
JS#ZS;IF (_JS<1);ed4=_ED4;JS#FESELSF;^h=_JS;ed4=_ED4;ret[ed4]=_JS;ELSE
^a=FESELAX;^h=ENONE;axiserr[^a]=ENONE
JS#WAITAMF(^a)
'Case 1: caddy is above inserter return 0
IF(felanap>allsafep);^h=ENONE
ELSE
'Check if position is within tolerance of a filter position
JS#QUFELP;IF( (_JS>=filterp1) & (_JS<=filterp8) );^h=ENONE
ELSE
IF ((_LFD<>1)|(_LRD<>0)); ^h=EFLTUNSF
ELSE
'Try to nudge elevator toward nearest valid position
'Compute number of steps between current encoder position and nominal 
' encoder position filter
JS#WAITAMF(^a)
^b=nearfilt-filterp1;'NB nearfilt is defermined by QUFELP
^b=felencp[^b]-felanap;'encoder distance to nearest filter pos
JS#ENC2STP(FESELAX,^b)
'Compute new desired position
~a=^a;^b=_TD~a+_JS
JS#FANCYMV(^a,^b);~a=^a;MC~a;~a=^a;MO~a
'Check the position again
JS#WAITAMF(^a)
JS#QUFELP
'If we still aren't in a safe spot fail
IF( ((_JS>=filterp1) & (_JS<=filterp8)) | (felanap>allsafep) );^h=ENONE
ELSE;^h= EFLTUNSF;axiserr[^a]=EFLTUNSF
ENDIF;ENDIF;ENDIF;ENDIF
axiserr[^a]=^h
ENDIF
EN,,^h


'***************************************************************************
' QUery Filter ELevator Position
' returns moving, filterp1,...,filterp8, filterld, intermd
' Does not consider inserter arm status
'***************************************************************************
#QUFELP
'Stack and XQ fancy footwork
JS#ZS;IF(_JS<1);ed4=_ED4;JS#QUFELP;^h=_JS;ed4=_ED4;ret[ed4]=_JS;ELSE
^a=FESELAX
~a=^a;IF((_SC~a=0) | (anapcln[^a]<>-1));^h=moving
ELSE
'Wait for filtered analog position to be clean
JS#WAITAMF(^a)
'Determine which filter is nearest current position 
'Compute abs(felencp[i]-position)
^f=felanap
^d=@ABS[(felencp[0]-^f)];^e=0;^b=1
'find minumum 
'^e=i of nearest filter
'^d=encoder dist to filter
#QUFELP1
^c=@ABS[felencp[^b]-^f]
IF (^c<^d);^d=^c;^e=^b;ENDIF;^b=^b+1
JP#QUFELP1,(^b<=nfilt)
'Store the nearest filter
nearfilt=^e+filterp1
'If minimum is < feselrg then we are in the position
IF(^d<feselrg)
'Convert ^e to the return value
^h=^e+filterp1
ELSE
'Not in position of a filter
^h=intermd
ENDIF
ENDIF
ENDIF
EN,,^h


'***************************************************************************
' GET FILTer
'   Report the current filter
'  Filter 1-8 In, Out?????TODO, None, Load, Moving, Intermediate
'***************************************************************************
#GETFILT
'Stack and XQ fancy footwork
JS#ZS;IF (_JS<1);JS#GETFILT;ed4=_ED4;ret[ed4]=0;ELSE
'Error status
IF(axiserr[FESELAX]<>ENONE);JS#ERRMSG(FESELAX,axiserr[FESELAX])
ELSE
^a=unknown
IF ((_LFD=0)&(_LRD=1));^a=in;ENDIF
IF ((_LFD=1)&(_LRD=0));^a=out;ENDIF
IF (_TSD & $80); ^a=moving;ENDIF
JS#QUFELP;^b=_JS
IF((^a=moving)|(^b=moving)|(filmove=1));MG "GETFILT: MOVING"
ELSE;IF(^b=filterld);MG "GETFILT: 9"
ELSE;IF(^a=unknown);MG "GETFILT: UNKNOWN"
ELSE;IF(^a=out);MG "GETFILT: 10"
ELSE;IF((^a=intermd)|(^b=intermd);MG "GETFILT: INTERMEDIATE"
ELSE;'One will match
IF(^b=filterp1);MG "GETFILT: 1";ENDIF
IF(^b=filterp2);MG "GETFILT: 2";ENDIF
IF(^b=filterp3);MG "GETFILT: 3";ENDIF
IF(^b=filterp4);MG "GETFILT: 4";ENDIF
IF(^b=filterp5);MG "GETFILT: 5";ENDIF
IF(^b=filterp6);MG "GETFILT: 6";ENDIF
IF(^b=filterp7);MG "GETFILT: 7";ENDIF
IF(^b=filterp8);MG "GETFILT: 8";ENDIF
ENDIF;ENDIF;ENDIF;ENDIF;ENDIF;ENDIF
ENDIF
EN


'***************************************************************************
' Pick FILter(filternum)
' 1-10,
' 1-8= Filters 1-8
' 9  = load position
' 10 = no filter
' Forces filternum to be integer
'***************************************************************************
#PICKFIL
'Stack and XQ fancy footwork
JS#ZS;IF (_JS<1);ed4=_ED4;JS#PICKFIL(a[ed4]);^h=_JS;ed4=_ED4;ret[ed4]=_JS;ELSE

'Hope for success, force filternum to an integer
^h=ENONE;axiserr[FESELAX]=ENONE;^a=@INT[^a]-1
'Check for invalid filter id
IF ((^a<0)|(^a>9));^h=EBADFP
ELSE;'ID valid, get current state of elevator (^b) and inserter (^c)
JS#WAITAMF(FESELAX);^d=(felencp[^a]-felanap)
JS#QUFELP;^b=_JS-filterp1
^c=unknown
IF ((_LFD=0)&(_LRD=1));^c=in;ENDIF
IF ((_LFD=1)&(_LRD=0));^c=out;ENDIF
IF (_TSD & $80); ^c=moving;ENDIF
'If the desired position = current position we are done
IF( ((^a=9)&(^c=out)) | ( ((^c=in)|(^a=8)) & (^b=^a) ) );^h=ENONE
ELSE;'We are not in position
'Set moving flag to prevent a race condition with query
filmove=1
'Stow the FESIN arm, note REFESIN ensures safe to move
JS#RMFESIN;^h=_JS
'If arm retracted, desired filter != none
IF ((^h=ENONE)&(_LRD=0)&(_LFD=1)&(^a<>9))
'Move to the desired filter
'NB ^a is index of requested filter position in felencp array
'^d is encoder distance to desired filter position
'^e=0 is a loop counter
^e=0
#PICKFI1
'Get steps to go
JS#ENC2STP(FESELAX,^d);^d=_TDE+_JS
JS#FANCYMV(FESELAX,^d);~a=FESELAX;MC~a;~a=FESELAX;MO~a
JS#WAITAMF(FESELAX);^d=(felencp[^a]-felanap);^e=^e+1
JP#PICKFI1,((^e<3) & (@ABS[^d]>feselrg))
'Double check we are in position
JS#QUFELP;^b=_JS
'If we are where we should be...
IF( ((^b-filterp1)=^a) & (^b<>intermd) )
'Insert the filter if needed
IF(^b<>filterld);JS#INFESIN;^h=_JS;ELSE;^h=ENONE;ENDIF
ELSE;^h=EFLTUNSF
REM MG "PICKFIL: EFLTUNSF"
ENDIF
ENDIF;ENDIF;ENDIF
axiserr[FESELAX]=^h
filmove=0;'be sure we've been set back to 0
ENDIF
EN,,^h


'***************************************************************************
' GET FLS Inserter status
' responds "IN" "OUT" "UNKNOWN" "INTERMEDIATE" "MOVING"
'***************************************************************************
#GETFLSI
'Stack and XQ fancy footwork
JS#ZS;IF (_JS<1);JS#GETFLSI;ed4=_ED4;ret[ed4]=0;ELSE
^a=FLSINAX
'Error status
IF(axiserr[^a]<>ENONE);JS#ERRMSG(^a,axiserr[^a])
ELSE
^h=unknown
IF ((_LFB=1)&(_LRB=0));^h=out;ENDIF
IF ((_LFB=0)&(_LRB=1));^h=in;ENDIF
IF (_TSB & $80); ^h=moving;ENDIF
IF (^h=out);MG "GETFLSI: OUT";ENDIF
IF (^h=moving);MG "GETFLSI: MOVING";ENDIF
IF (^h=in);MG "GETFLSI: IN";ENDIF
IF (^h=unknown);MG "GETFLSI: UNKNOWN";ENDIF
ENDIF;ENDIF
EN


'***************************************************************************
' INsert FLS INserter arm
'***************************************************************************
#INFLSIN
'Stack and XQ fancy footwork
JS#ZS;IF (_JS<1);JS#INFLSIN;^h=_JS;ed4=_ED4;ret[ed4]=_JS;ELSE
^h=ENONE;^a=FLSINAX;axiserr[^a]=ENONE
IF(_LFB=1);JS#MOV2LIM(^a, axaccel[^a], axdecel[^a], axlmspd[^a]);^h=_JS;ENDIF
IF(^h=ENONE);^b=(_TDB-flsbkof);JS#FANCYMV(^a,^b);ENDIF
~a=^a;MC~a;~a=^a;MO~a
IF ((_LFB=1) | (_LRB=0)); ^h=ELIMSWF;ENDIF
axiserr[^a]=^h
ENDIF
EN,,^h


'***************************************************************************
' ReMove FLS INserter arm
' NB it is always safe to remove
'***************************************************************************
#RMFLSIN
'Stack and XQ fancy footwork
JS#ZS;IF (_JS<1);JS#RMFLSIN;^h=_JS;ed4=_ED4;ret[ed4]=_JS;ELSE
^h=ENONE;^a=FLSINAX;axiserr[^a]=ENONE
IF(_LRB=1)
JS#MOV2LIM(^a, axaccel[^a], axdecel[^a], -axlmspd[^a]);^h=_JS
~a=^a;MC~a;~a=^a;MO~a
ENDIF
IF ((_LFB=0)|(_LRB=1));^h=ELIMSWF;ENDIF
axiserr[^a]=^h;'Store status
ENDIF
EN,,^h


'***************************************************************************
' CALibrate HoMe-switched, unencoded AXis(axis)
' Calibrate an axis that has a home switch but no encoder
' If home switch fails then sends EHMERR
' Does not turn axis off if sucessful, 
' For use on axes w/o pot & with a Home switch (HRTLT,HRAZ)
' Returns 0 iff sucessful
'***************************************************************************
#CALHMAX;'(axis)
'Stack and XQ fancy footwork
JS#ZS;IF (_JS<1);ed4=_ED4;JS#CALHMAX(a[ed4]);^h=_JS;ed4=_ED4;ret[ed4]=_JS;ELSE
IF ((^a<>HRTLTAX)&(^a<>HRAZAX));^h=EBADAX
ELSE
^h=ENONE;axiserr[^a]=ENONE
JS#MOV2LIM(^a, axaccel[^a], axdecel[^a], -axlmspd[^a]);^h=_JS
IF (^h=ENONE)
~a=^a;HV~a=axhmspd[^a];SP~a=axspd[^a];DC~a=axdecel[^a];SH~a;HM~a;BG~a
~a=^a;MC~a
'If we didn't stop because of homing then the home switch broke.
~a=^a;IF(_SC~a<>10);ST~a;MC~a;~a=^a;MO~a;^h=EHMERR
ELSE;'Define the new position as home
~a=^a;MC~a;~a=^a;DP~a=0;axiscal[^a]=true;^h=0;ldelta[^a]=-10*bcklsh[^a]
ENDIF;ENDIF;ENDIF
axiserr[^a]=^h
ENDIF
EN ,,^h


'***************************************************************************
' CALibrate ENcoded AXis(axis)
' Calibrate an axis that has an analog encoder
' Does not turn axis off if sucessful
' For use with GES only
' Returns 0 iff sucessful
'***************************************************************************
#CALENAX
'Stack and XQ fancy footwork
JS#ZS;IF(_JS<1);ed4=_ED4;JS#CALENAX(a[ed4]);^h=_JS;ed4=_ED4;ret[ed4]=_JS;ELSE
IF(^a<>GESAX);^h=EBADAX
ELSE
'Hope for success
^h=ENONE;axiserr[^a]=ENONE
'Wait for filtered analog position to be clean
JS#WAITAMF(^a);^b=analogp[^a]
'If pot reads close to the negative limit move positive by a little
~a=^a;IF((^b < encnlim[^a])|(_LR~a<>1))
^b=1024;'5*(encnlim[^a]-^b)
JS#ENC2STP(^a,^b);~a=^a;AC~a=axaccel[^a]; DC~a=axdecel[^a];SP~a=axspd[^a]
'MG "Pot reads close to the -limit move positive a little", ^b,_JS
~a=^a;PR~a=_JS;SH~a;BG~a;MC~a
ENDIF
'MG "Wait"
'Wait for clean analog position and Overestimate distance to -limit
JS#WAITAMF(^a);JS#ENC2STP(^a,analogp[^a]);^b=2*_JS
'MG "Overest dist to -lim and start a move to past limit",-^b
~a=^a;AC~a=axaccel[^a];DC~a=axdecel[^a];SP~a=axlmspd[^a];PR~a=-^b;SH~a;BG~a
'Wait until stopped
#CALENA1;WT500;~a=^a;JP#CALENA1, (_SC~a=0);~a=^a;MC~a
'If we weren't stopped by the -limit, fail
~a=^a;IF(_SC~a<>3);^h=ELIMSWF
'MG"Not stopped by -limit,fail."
ELSE
'If we somehow overshot limit move forward slowly until on limit
~a=^a;IF(_LR~a=1)
'Try to move back onto the limit, 500 counts willbe plenty
JS#ENC2STP(^a,500);^b=_JS
'MG "overshot limit move forward slowly until on limit",^b
~a=^a;SP~a=axhmspd[^a];PR~a=^b;BG~a
#CALENA2;WT 50;~a=^a;JP#CALENA2, (_LR~a=1);ST~a;MC~a
'If negative movement is allowed then the switch failed 
'  or we managed to overshoot twice it either way this is a fail
~a=^a;IF(_LR~a=1);^h=ELIMOST;ENDIF
ENDIF
'If all is well
IF(^h=ENONE)
WT 500
'500 counts is plenty to move totally off the negative limit
JS#ENC2STP(^a,500);^b=_JS
'Move off limit slowly and stop
~a=^a;PR~a=^b;BG~a
#CALENA3;WT 25;~a=^a;JP#CALENA3, ((_LR~a=0) & (_SC~a=0));ST~a;MC~a
'If we didn't get off the limit, fail
~a=^a;IF(_LR~a=0);^h=ELIMSWF;ENDIF
ENDIF
ENDIF
'If success, make this the reference position
IF (^h=ENONE)
'MG "Calibrated axis",^a
JS#ZERSTP(^a);axiscal[^a]=true;ldelta[^a]=10*bcklsh[^a]
ELSE
'MG "Failed to calibrate axis",^a
~a=^a;MC~a;~a=^a;MO~a
ENDIF
ENDIF
axiserr[^a]=^h;'Store status
ENDIF
EN,,^h


'***************************************************************************
' Fancy MoVe(axis, position)
' Start a move to position on the specified axis, accounting for
'  both minimum incremental motion & backlash
'***************************************************************************
#FANCYMV;'(axis,absolute)
'Stack and XQ fancy footwork
JS#ZS;IF(_JS<1);ed4=_ED4;JS#FANCYMV(a[ed4],b[ed4]);ed4=_ED4;ret[ed4]=_JS;ELSE
^h=ENONE
'Compute delta
^b=@RND[^b]
~a=^a;^c=^b-_TD~a
IF(^c<>0)
REM ~a=^a;MG "FANCYMV: Move axis",^a," from",_TD~a," to",^b
'If required move is less than the minimum increment
IF(@ABS[^c]<mininc[^a])
'First move mininc[^a]+@ABS[^c] in direction we last headed
IF(ldelta[^a]>0);~a=^a;^d=_TD~a+mininc[^a]+@ABS[^c]
ELSE;~a=^a;^d=_TD~a-mininc[^a]-@ABS[^c];ENDIF
~a=^a;AC~a=axaccel[^a];DC~a=axdecel[^a];SP~a=axlmspd[^a]
'Verify the limit isn't tripped in the the direction of inteded motion
'Will evaluate to cmd err if only a sigle limit is disabled
'The instrument doesnt use have LD= 1 or 2 so non issue 
~a=^a;IF((_LD~a<>3)&((ldelta[^a]>0)&(_LF~a=0)) | ((ldelta[^a]<0)&(_LR~a=0)) )
'Starting the move will cause a command error
^h=ELIMSW
ELSE
~a=^a;PA~a=^d;SH~a;BG~a;MC~a
ENDIF
'Check position to see if we didn't reach our goal (i.e. we hit a limit)
~a=^a;IF(_TD~a<>^d)
'Figure how far we need to move in the other direction
IF(ldelta[^a]>0);~a=^a;^d=_TD~a-(2*(mininc[^a]+@ABS[^c]))
ELSE;~a=^a;^d=_TD~a+(2*(mininc[^a]+@ABS[^c]));ENDIF
'Compute delta
~a=^a;^e=^d-_TD~a
'Handle backlash
JS#BACKLSH(^a,^e)
'Move past in the other direction
'Verify the limit isn't tripped in the the direction of inteded motion
~a=^a;IF((_LD~a<>3)& ((^e>0)&(_LF~a=0)) | ((^e<0)&(_LR~a=0)) )
'Starting the move will cause a command error
^h=ELIMSW
ELSE
~a=^a;PA~a=^d;SH~a;BG~a;MC~a
ENDIF
ENDIF;' didn't reach goal
'Recompute delta
~a=^a;^c=^b-_TD~a
ENDIF;' very small move
'Handle backlash
JS#BACKLSH(^a,^c)
'Start move to position
'Verify the limit isn't tripped in the the direction of inteded motion
~a=^a;IF((_LD~a<>3)& ((^c>0)&(_LF~a=0)) | ((^c<0)&(_LR~a=0)) )
'Starting the move will cause a command error
^h=ELIMSW
ELSE
~a=^a;AC~a=axaccel[^a];DC~a=axdecel[^a];SP~a=axspd[^a]
'NB setting TW to value larger than max is ok
~a=^a;PA~a=^b;SH~a
~a=^a;TW~a=(@ABS[(1100*((^b-_TD~a)/_SP~a))]+100);BG~a
ENDIF
ENDIF;'nonzero move
ENDIF;'footwork
EN 1,,^h


'***************************************************************************
' Move to limit (axis, acceleration, deceleration, velocity)
' If limit doesn't engage sends ELIMSWF
' velocity must not be 0
' Intended for uncalibrated use
'***************************************************************************
#MOV2LIM
REM These first two lines are problematic for the FLSIN & FESIM,
REM  if it becomes necessary to enable them
REM At present only the GES is physically capable of overshooting its limits
REM  If we didn't last stop because of the opposite limit
REM   move away from the limit we want be just a bit so account for having 
REM   potentially overshot it.
REM IF(^d>0);^e=-axlmos[^a];^f=3;ELSE;^e=axlmos[^a];^f=2;ENDIF;
REM ~a=^a;AC~a=^b; DC~a=^c;IF(_SC~a<>^f);PR~a=^e; BG~a;MC~a;ENDIF;

'Stack and XQ fancy footwork
JS#ZS
IF(_JS<1);ed4=_ED4;JS#MOV2LIM(a[ed4],b[ed4],c[ed4],d[ed4])
^h=_JS;ed4=_ED4;ret[ed4]=_JS
ELSE
^h=ENONE;'Hope success
'If we are at the limit then we are done!
~a=^a;^f=(((_LR~a<>0)|(^d>0))&((_LF~a<>0)|(^d<0)))
REM ~a=^a;'MG ^a,^f,^d,_LR~a,_LF~a
IF(^f)
' when calibrated, we could tighten the move distance estimate
^e=(axmaxp[^a]-axminp[^a])*1.1
'Begin move (-limit if neg, +lim if pos) wait until limit or timeout
~a=^a;AC~a=^b;DC~a=^c;SP~a=^d;IF(^d>0);PR~a=^e;ELSE;PR~a=-^e;ENDIF;SH~a;BG~a
'Wait until we stop moving
#MOV2LI1;WT 100;~a=^a;JP#MOV2LI1, (_SC~a = 0);~a=^a;MC~a
'Determine the expected stop code & lest the last delta
IF(^d>0);ldelta[^a]=^e;^f=2;ELSE;ldelta[^a]=-^e;^f=3;ENDIF
'If the stop code is not that for the expected limit switch we failed
~a=^a;IF (_SC~a<>^f);MO~a;^h=ELIMSWF;ENDIF
ENDIF
axiserr[^a]=^h;'Store status
ENDIF
EN ,,^h


'***************************************************************************
' Direction Change Query (Axis,position delta/direction)
' For internal use only
'***************************************************************************
#DIRCNGQ
EN,,(((ldelta[^a]<0)&(^b>0)) | ((ldelta[^a]>0)&(^b<0)))


'***************************************************************************
' Back LaSH correction(axis, position delta)
' Routine applies a backlash correction if direction change
' For internal use only
'***************************************************************************
#BACKLSH
'Figure out if a change in direction
JS#DIRCNGQ(^a,^b)
IF(_JS=true)
'Correct for backlash by simply changing the current position
~a=^a;IF(^b>0);^c=_TD~a-bcklsh[^a];ELSE;^c=_TD~a+bcklsh[^a];ENDIF
JS#DPWAFE(^a,^c)
ENDIF
ldelta[^a]=^b
EN


'***************************************************************************
' Check Sanity(axis, position)
'  Return true if position is, potentially, physically realizeable.
'  False otherwise 
'  For internal use only
'***************************************************************************
#SANEPOS
EN,,((^b>=axminp[^a]) & (^b<=axmaxp[^a]))


'***************************************************************************
' ANAlog Moving Average Filter
' Locals:
'   ^a=index counter
'   ^b=filter size
'   ^c=filter size -1
'   ^d=running total for GES
'   ^e=running total for FESEL
'   ^f=running total for FOC
' Arrays:
'   gespacu, felpacu, focpacu Accumulator arrays for the average
' Output (GLOBAL):
'   gesanap  filtered GES position
'   felanap  filtered FESEL position
'   focanap  filtered FOC position
'   analogp[8]  filter analog positions for each axis, only the GES,FESEL, &
'            FOC axes are meaningful
' For internal use only
'***************************************************************************
#ANAMAF
JS#ZS;IF (_JS<1);JS#ANAMAF
ELSE
^b=ANAMAFSZ;^c=^b-1
~a=GESAX;gesanap=_TP~a
~a=FESELAX;felanap=_TP~a
~a=FOCAX;focanap=_TP~a
^d=gesanap*^c;^e=felanap*^c;^f=focanap*^c
DA gespacu[0], felpacu[0], focpacu[0]
DM gespacu[^b], felpacu[^b], focpacu[^b]
REM Initialize array with analog encoder values
^a=0
#ANAMAF1
~a=GESAX;gespacu[^a]=_TP~a
~a=FESELAX;felpacu[^a]=_TP~a
~a=FOCAX;focpacu[^a]=_TP~a
^a=^a+1
JP#ANAMAF1,^a<^b
'#ANAMAF2 is the filter.  It takes the most recent reading,
'  tosses out the oldest reading, sums the values and takes an average.
^a=0;AT0
#ANAMAF2
'If axis is in motion, update the index of the most recent dirty value
~a=GESAX;IF(_TS~a & $80);anapcln[GESAX]=^a;ENDIF
~a=FOCAX;IF(_TS~a & $80);anapcln[FOCAX]=^a;ENDIF
~a=FESELAX;IF(_TS~a & $80);anapcln[FESELAX]=^a;ENDIF
'Current value
~a=GESAX;gespacu[^a]=_TP~a
~a=FESELAX;felpacu[^a]=_TP~a
~a=FOCAX;focpacu[^a]=_TP~a
'sum in current value and subtract oldest value
^g=^a+1
^d=^d-gespacu[^g]+gespacu[^a]
^e=^e-felpacu[^g]+felpacu[^a]
^f=^f-focpacu[^g]+focpacu[^a]
'Store filtered readings
gesanap=^d/^c;felanap=^e/^c;focanap=^f/^c
analogp[GESAX]=gesanap;analogp[FESELAX]=felanap;analogp[FOCAX]=focanap
^a=^g
'See if the reading is clear of motion contamination
IF(anapcln[GESAX]=^a);anapcln[GESAX]=-1;ENDIF
IF(anapcln[FESELAX]=^a);anapcln[FESELAX]=-1;ENDIF
IF(anapcln[FOCAX]=^a);anapcln[FOCAX]=-1;ENDIF
'If last read then subtract first array element and reset ^a
'MG TIME-^g
AT-1;JP#ANAMAF2,^a<^c
'If axis is in motion, update the index of the most recent dirty value
~a=GESAX;IF(_TS~a & $80);anapcln[GESAX]=^a;ENDIF
~a=FOCAX;IF(_TS~a & $80);anapcln[FOCAX]=^a;ENDIF
~a=FESELAX;IF(_TS~a & $80);anapcln[FESELAX]=^a;ENDIF
'Current value
~a=GESAX;gespacu[^a]=_TP~a
~a=FESELAX;felpacu[^a]=_TP~a
~a=FOCAX;focpacu[^a]=_TP~a;
'sum in current value and subract oldest value
^d=^d-gespacu[0]+gespacu[^a]
^e=^e-felpacu[0]+felpacu[^a]
^f=^f-focpacu[0]+focpacu[^a]
'Store filtered readings
gesanap=^d/^c;felanap=^e/^c;focanap=^f/^c
analogp[GESAX]=gesanap;analogp[FESELAX]=felanap;analogp[FOCAX]=focanap
^a=0
'See if the reading is clear of motion contamination
IF(anapcln[GESAX]=^a);anapcln[GESAX]=-1;ENDIF
IF(anapcln[FESELAX]=^a);anapcln[FESELAX]=-1;ENDIF
IF(anapcln[FOCAX]=^a);anapcln[FOCAX]=-1;ENDIF
'MG TIME-^h,gesanap,felanap,focanap
AT-1;JP#ANAMAF2
ENDIF
EN


'***************************************************************************
' WAITAMF(axis) Wait for the analog moving average filter to refresh for
'  the specified axis
'***************************************************************************
#WAITAMF
'Stack and XQ fancy footwork
JS#ZS;IF(_JS<1);ed4=_ED4;JS#WAITAMF(a[ed4]);ed4=_ED4;ret[ed4]=0;ELSE
IF (anapcln[^a]<>-1)
REM MG "Waiting...";^b=TIME
#WAITAM1;WT200;JP#WAITAM1,(anapcln[^a]<>-1)
REM ^c=TIME-^b;MG ^c," ms."
ENDIF;ENDIF
EN


'***************************************************************************
' ZERO ARRay
' Zeros the contents of the array
' For internal use only
'***************************************************************************
#ZEROARR;^b=^a[-1];^c=0
#ZEROAR1;^a[^c]=0;^c=^c+1;JP#ZEROAR1,(^c<^b);EN


'***************************************************************************
' Mean of an ARRay
' For internal use only
'***************************************************************************
#MEANARR
^b=^a[-1];^c=0;^d=0
#MEANAR1;^d=^d+^a[^c];^c=^c+1;JP#MEANAR1,(^c<^b)
EN,,^d/^b


'***************************************************************************
' Standard Deviation of an array, must pass mean as arg 2
' For internal use only
'***************************************************************************
#STDDEV
^c=^a[-1];^d=0;^e=0
#STDDEV1;^g=^a[^d]-^b;^e=^e+(^g*^g);^d=^d+1;JP#STDDEV1,(^d<^c)
EN,,@SQR[^e/^c]


'***************************************************************************
' Tell Switch status
'***************************************************************************
#TELLTS;
'Stack and XQ fancy footwork
JS#ZS;IF (_JS<1);ed4=_ED4;JS#TELLTS(a[ed4]);ret[ed4]=ENONE;ELSE
~a=^a;^b=_TS~a;MG "Axis ",~a
IF (^b & $80);MG "In motion";ELSE;MG "Stopped";ENDIF
IF (^b & $40);MG "Axis error exceeds error limit";ENDIF
IF (^b & $20);MG "Motor Off";ELSE;MG "Motor On";ENDIF
IF (^b & $08);NO;ELSE;MG "Forward Limit Tripped";ENDIF
IF (^b & $04);NO;ELSE;MG "Reverse Limit Tripped";ENDIF
IF (^b & $02);MG "Home 1";ELSE;MG "Home 0";ENDIF
IF (^b & $01);MG "Axis Latched";ENDIF
~a=^a;IF (@IN[~a-60]) ;MG "Axis Abort 1";ELSE;MG "Axis Abort 0";ENDIF
ENDIF
EN


'***************************************************************************
' ZERo STePper counts(axis)
'   Zeros the stepper counts for axis, at current position, 
'  regardless of analog feedback status, preserves AF
' Define Position With Analog Feedback Enabled(axis,position)
' For internal use only
'***************************************************************************
#ZERSTP;^b=0
#DPWAFE
~a=^a;^g=_AF~a;AF~a=0
IF(^a=GESAX);~a=^a;DP~a=^b;rstpm[GESPM]=1
ELSE;IF(^a=FESELAX);~a=^a;DP~a=^b;rstpm[FESELPM]=1
ELSE;~a=^a;DP~a=^b;ENDIF;ENDIF
~a=^a;AF~a=^g;
EN


'***************************************************************************
' ENCoder counts to STePs(axis, counts) 
' For internal use only
'***************************************************************************
#ENC2STP
'MG "Counts: ",^b
~a=^a;^h=(^b*_YA~a*_YB~a)/_YC~a
'MG "To Steps: ",^h
EN,,^h


'***************************************************************************
' STePs to ENCoder counts(axis, steps)
' For internal use only
'***************************************************************************
#STP2ENC
~a=^a;^h=(^b*_YC~a)/(_YA~a*_YB~a)
EN,,^h


'***************************************************************************
' MOVTIME(dist,speed,accel,decel)
' Compute the time travel would theoretically take in units of the RTC
' For internal use only
'***************************************************************************
#MOVTIME
REM a=^a;b=^b;c=^c;d=^d
REM MG "Move Time:",^a,^b,^c,^d
EN,,(@ABS[^a/^b]+(0.5*@ABS[(^b/^c)+(^b/^d)]))*(1000000/_TM)


'***************************************************************************
' ERRor MeSsaGe(axis, error,...)
'  Reports the specified error
' For Internal use only
'***************************************************************************
#ERRMSG
IF (^a=GESAX)
IF (^b=ENONE);MG "GES: OK"
ELSE;IF (^b=ETIME);MG "!GES:ERRMotion Timeout."
ELSE;IF (^b=EPOTJAM);MG "!GES:ERRPot not changing with steps."
ELSE;IF (^b=ELIMSWF);MG "!GES:ERRLimit switch failure."
ELSE;IF (^b=EGESPMM)
MG "!GES:ERREncoder & stepper mismatch. Try recalibrating.",gesanap,_TDA
ELSE;IF (^b=EFAIL);MG "!GES:ERRFail."
ELSE;IF (^b=ECRAZY);MG "!GES:ERRRequested value out of allowed range."
ELSE;IF (^b=ELIMOST);MG "!GES:ERROvershot limit switch."
ELSE;IF (^b=ELIMSW);MG "!GES:ERRLimit switch."
ELSE;IF (^b=EBADAX);MG "!GES:ERRRoutine not for this axis."
ELSE;MG "!GES:ERRUnknown error code",^b,". This is a software bug."
ENDIF;ENDIF;ENDIF;ENDIF;ENDIF;ENDIF;ENDIF;ENDIF;ENDIF;ENDIF
ENDIF
IF (^a=HRTLTAX)
IF (^b=ENONE);MG "HRTLT: OK"
ELSE;IF (^b=ETIME);MG "!HRTLT:ERRMotion Timeout."
ELSE;IF (^b=EHMERR);MG "!HRTLT:ERRHoming failure. Switch did not toggle."
ELSE;IF (^b=ELIMSWF);MG "!HRTLT:ERRLimit switch failure."
ELSE;IF (^b=ELCKERR);MG "!HRTLT:ERRLocked. You must loosen the locking nut."
ELSE;IF (^b=ECRAZY);MG "!HRTLT:ERRRequested value out of allowed range."
ELSE;IF (^b=EFAIL);MG "!HRTLT:ERRFail."
ELSE;IF (^b=ELIMSW);MG "!HRTLT:ERRLimit switch."
ELSE;IF (^b=EBADAX);MG "!HRTLT:ERRRoutine not for this axis."
ELSE;MG "!HRTLT:ERRUnknown error code",^b,". This is a software bug."
ENDIF;ENDIF;ENDIF;ENDIF;ENDIF;ENDIF;ENDIF;ENDIF;ENDIF
ENDIF
IF (^a=HRAZAX)
IF (^b=ENONE);MG "HRAZ: OK"
ELSE;IF (^b=ETIME);MG "!HRAZ:ERRMotion Timeout."
ELSE;IF (^b=EHMERR);MG "!HRAZ:ERRHoming failure. Switch did not toggle."
ELSE;IF (^b=ELIMSWF);MG "!HRAZ:ERRLimit switch failure."
ELSE;IF (^b=ELCKERR);MG "!HRAZ:ERRLocked. You must loosen the locking nut."
ELSE;IF (^b=ECRAZY);MG "!HRAZ:ERRRequested value out of allowed range."
ELSE;IF (^b=EFAIL);MG "!HRAZ:ERRFail."
ELSE;IF (^b=ELIMSW);MG "!HRAZ:ERRLimit switch."
ELSE;IF (^b=EBADAX);MG "!HRAZ:ERRRoutine not for this axis."
ELSE;MG "!HRAZ: Unknown error code",^b,". This is a software bug."
ENDIF;ENDIF;ENDIF;ENDIF;ENDIF;ENDIF;ENDIF;ENDIF;ENDIF
ENDIF
IF (^a=LRTLTAX)
IF (^b=ENONE);MG "LRTLT: OK"
ELSE;IF (^b=ETIME);MG "!LRTLT:ERRMotion Timeout."
ELSE;IF (^b=EHMERR);MG "!LRTLT:ERRHoming failure. Switch did not toggle."
ELSE;IF (^b=ECRAZY);MG "!LRTLT:ERRRequested value out of allowed range."
ELSE;IF (^b=EFAIL);MG "!LRTLT:ERRFail."
ELSE;IF (^b=EBADAX);MG "!LRTLT:ERRRoutine not for this axis."
ELSE;MG "!LRTLT:ERRUnknown error code",^b,". This is a software bug."
ENDIF;ENDIF;ENDIF;ENDIF;ENDIF;ENDIF
ENDIF
IF (^a=FOCAX)
IF (^b=ENONE);MG "FOC: OK"
ELSE;IF (^b=ETIME);MG "!FOC:ERRMotion Timeout."
ELSE;IF (^b=ECRAZY);MG "!FOC:ERRRequested value out of allowed range."
ELSE;IF (^b=EFAIL);MG "!FOC:ERRFail."
ELSE;IF (^b=EBADAX);MG "!FOC:ERRRoutine not for this axis."
ELSE;MG "!FOC:ERRUnknown error code",^b,". This is a software bug."
ENDIF;ENDIF;ENDIF;ENDIF;ENDIF
ENDIF
IF (^a=FLSINAX)
IF (^b=ENONE);MG "FLSIN: OK"
ELSE;IF (^b=ETIME);MG "!FLSIN:ERRMotion Timeout."
ELSE;IF (^b=ELIMSWF);MG "!FLSIN:ERRLimit switch failure."
ELSE;IF (^b=EHMERR);MG "!FLSIN:ERRHoming failure. Switch did not toggle."
ELSE;IF (^b=ECRAZY);MG "!FLSIN:ERRRequested value out of allowed range."
ELSE;IF (^b=EFAIL);MG "!FLSIN:ERRFail."
ELSE;IF (^b=ELIMSW);MG "!FLSIN:ERRLimit switch."
ELSE;IF (^b=EBADAX);MG "!FLSIN:ERRRoutine not for this axis."
ELSE;MG "!FLSIN:ERRUnknown error code",^b,". This is a software bug."
ENDIF;ENDIF;ENDIF;ENDIF;ENDIF;ENDIF;ENDIF;ENDIF
ENDIF
IF (^a=FESINAX)
IF (^b=ENONE);MG "FESIN: OK"
ELSE;IF (^b=ETIME);MG "!FESIN:ERRMotion Timeout."
ELSE;IF (^b=ELIMSWF);MG "!FESIN:ERRLimit switch failure."
ELSE;IF (^b=EHMERR);MG "!FESIN:ERRHoming failure. Switch did not toggle."
ELSE;IF (^b=ECRAZY);MG "!FESIN:ERRRequested value out of allowed range."
ELSE;IF (^b=EFAIL);MG "!FESIN:ERRUFail."
ELSE;IF (^b=ELIMSW);MG "!FESIN:ERRLimit switch."
ELSE;IF (^b=EBADAX);MG "!FESIN:ERRRoutine not for this axis."
ELSE;MG "!FESIN:ERRUnknown error code",^b,". This is a software bug."
ENDIF;ENDIF;ENDIF;ENDIF;ENDIF;ENDIF;ENDIF;ENDIF
ENDIF
IF (^a=FESELAX)
IF (^b=ENONE);MG "FESEL: OK"
ELSE;IF (^b=ETIME);MG "!FESEL:ERRMotion Timeout."
ELSE;IF (^b=EPOTJAM);MG "!FESEL: ERRPot not changing with steps."
ELSE;IF (^b=ELIMSWF);MG "!FESEL:ERR Limit switch failure."
ELSE;IF (^b=EHMERR);MG "!FESEL: ERRHoming failure. Switch did not toggle."
ELSE;IF (^b=EBADFP)
MG "!FESEL: ERR",^c {Z2.0}," is not a valid filter position."
ELSE;IF (^b=ECRAZY);MG "!FESEL: ERRRequested value out of allowed range."
ELSE;IF (^b=EFAIL);MG "!FESEL: ERRFail."
ELSE;IF (^b=EBADAX);MG "!FESEL:ERRRoutine not for this axis."
ELSE;IF (^b=EFLTUNSF);MG "!FESEL:ERRFilter changer unsafe state. Fix Manually."
ELSE;MG "!FESEL:ERRUnknown error code",^b,". This is a software bug."
ENDIF;ENDIF;ENDIF;ENDIF;ENDIF;ENDIF;ENDIF;ENDIF;ENDIF;ENDIF
ENDIF
axiserr[^a]=ENONE
EN


'***************************************************************************
' Tell Amplifier status
'***************************************************************************
#TELLTA
IF (_TA0 & $10);MG "Over Current (E-H Axes)";ENDIF
IF (_TA0 & $1);MG "Over Current (A-D Axes)";ENDIF
IF (_TA3 & $2);MG "ELO Active (E-H Axes)";ENDIF
IF (_TA3 & $1);MG "ELO Active (A-D Axes)";ENDIF
EN


'***************************************************************************
' Command Error Interrupt
' Routine executed whenever a program error occurs
'***************************************************************************
#CMDERR
IF((_ED1=2)&(_TC=7))
'MOMON is trying to kill motors but they are running, ignore
ELSE
MG "#!CMDERR:ERR",_TC," (thread",_ED1," line",_ED,"):"
ENDIF
EN


'***************************************************************************
' Tell Running Threads
'***************************************************************************
#RUNNIN;MG "Active Threads",_HX0,_HX1,_HX2,_HX3,_HX4,_HX5,_HX6,_HX7;EN


'***************************************************************************
' ZS
' Returns the stack level of the calling subtoutine
'***************************************************************************
#ZS
IF(_ED4=0);zs=_ZS0;ENDIF;IF(_ED4=1);zs=_ZS1;ENDIF;IF(_ED4=2);zs=_ZS2;ENDIF
IF(_ED4=3);zs=_ZS3;ENDIF;IF(_ED4=4);zs=_ZS4;ENDIF;IF(_ED4=5);zs=_ZS5;ENDIF
IF(_ED4=6);zs=_ZS6;ENDIF;IF(_ED4=7);zs=_ZS7;ENDIF
EN,,zs-1
