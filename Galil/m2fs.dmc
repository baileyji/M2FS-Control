REM ISR routines (e.g. ININT) always interrupt thread 0.
REM If a limit caused deceleration at SD rate and a ST 
REM   is issued the deceleration rate is not changed.
REM ST changes the stop code even if an axis is already stopped.
REM It appears that ^a, etc only get pushed onto the stack from the 2nd level down
REM also, it does not appear there is a way to use introspection to determine 
REM what stack depth a function is at
'***************************************************************************
' Initial Configuration
'***************************************************************************
#INIT
ST;MC;MO*
REM Defines
GESAX=0
FLSINAX=1
FOCAX=2
FESINAX=3
FESELAX=4
LRTLTAX=5
HRTLTAX=6
HRAZAX=7

'Logic States
true=1;false=0

ENONE=0;'All is well
EHMERR=3;'HoMeingERRor
EPOTJAM=4;'POTJAMmed
ELIMSWF=5;'LIMitSWitchFail
ELCKERR=6;'LockError
EBADFP=7;'BADFilterPos
EGESPMM=8;'GESPotMotorMismatch
EFAIL=9
ECRAZY=11;'A passed parameter is outside of all sane bounds
ELIMOST=12;' Over shot the limitswitch
EFLTUNSF=13

'Array of threaded execution parameters
DM a[8],b[8],c[8],d[8],e[8],f[8],g[8],h[8],ret[8]
a[0]=0;a[1]=0;a[2]=0;a[3]=0;a[4]=0;a[5]=0;a[6]=0;a[7]=0
b[0]=0;b[1]=0;b[2]=0;b[3]=0;b[4]=0;b[5]=0;b[6]=0;b[7]=0
c[0]=0;c[1]=0;c[2]=0;c[3]=0;c[4]=0;c[5]=0;c[6]=0;c[7]=0
d[0]=0;d[1]=0;d[2]=0;d[3]=0;d[4]=0;d[5]=0;d[6]=0;d[7]=0
e[0]=0;e[1]=0;e[2]=0;e[3]=0;e[4]=0;e[5]=0;e[6]=0;e[7]=0
f[0]=0;f[1]=0;f[2]=0;f[3]=0;f[4]=0;f[5]=0;f[6]=0;f[7]=0
g[0]=0;g[1]=0;g[2]=0;g[3]=0;g[4]=0;g[5]=0;g[6]=0;g[7]=0
h[0]=0;h[1]=0;h[2]=0;h[3]=0;h[4]=0;h[5]=0;h[6]=0;h[7]=0
ret[0]=0;ret[1]=0;ret[2]=0;ret[3]=0;ret[4]=0;ret[5]=0;ret[6]=0;ret[7]=0

'Possible Axis positions
out=0
in=1
moving=2
intermd=3
unknown=4
lores=5
hires=6
settle=7
lrswap=8
filterp1=9
'rest of filter position enums are set automatically
filterp2=filterp1+1;filterp3=filterp1+2;filterp4=filterp1+3;filterp5=filterp1+4
filterp6=filterp1+5;filterp7=filterp1+6;filterp8=filterp1+7;filterld=filterp1+8

'Pot monitoring
potjam=1
'Value must be set to 1 atomically when zeroing the position of an encoded axis
GESPM=0;FESELPM=1;DM rstpm[2];rstpm[GESPM]=false;rstpm[FESELPM]=false


'Analog Position Filtering
ANAMAFSZ=1000
DM analogp[8]
~a=GESAX;gesanap=_TP~a;analogp[GESAX]=gesanap
~a=FOCAX;focanap=_TP~a;analogp[FOCAX]=focanap
~a=FESELAX;felanap=_TP~a;analogp[FESELAX]=felanap
DM anapcln[8];'Whether or not motion has dirtied the filtered reading
'-1 if reading is clean
anapcln[GESAX]=-1
anapcln[FOCAX]=-1
anapcln[FESELAX]=-1

REM Absolutly do not consider a value final unless it has a comment!
REM  (or the instrument is on the telescope and in use, then Mea Culpa -JB)
DM axaccel[8];'Generic Acceleration rate
axaccel[GESAX]=100000
axaccel[FLSINAX]=256000
axaccel[FOCAX]=100000
axaccel[FESINAX]=256000
axaccel[FESELAX]=256000
axaccel[LRTLTAX]=100000
axaccel[HRTLTAX]=100000
axaccel[HRAZAX]=100000
DM axdecel[8];'Generic Deceleration rate
axdecel[GESAX]=100000
axdecel[FLSINAX]=256000
axdecel[FOCAX]=100000
axdecel[FESINAX]=256000
axdecel[FESELAX]=256000
axdecel[LRTLTAX]=190000
axdecel[HRTLTAX]=160000;'5/6 * 15000um/s^2/0.078um/us=160256
axdecel[HRAZAX]=160000;'5/6 * 15000um/s^2/0.078um/us=160256
REM NB The PI actuators advise no greater than 10% max speed
REM    when approaching limits.
DM axlmspd[8];'limit speed (speed used when intentionally moving to a limit)
axlmspd[GESAX]=6400
axlmspd[FLSINAX]=1024
axlmspd[FOCAX]=6400;'unused
axlmspd[FESINAX]=1024
axlmspd[FESELAX]=6400
axlmspd[LRTLTAX]=6400;'unused
axlmspd[HRTLTAX]=6400
axlmspd[HRAZAX]=6400
DM axhmspd[8];'homing speed, used when returning to home after overshoot
'Consider steeing in terms of time to get back
' e.g. HV=axspd^2/2/axlgdcl/desired return time
axhmspd[GESAX]=256
axhmspd[FLSINAX]=256
axhmspd[FOCAX]=256
axhmspd[FESINAX]=256
axhmspd[FESELAX]=256
axhmspd[LRTLTAX]=256
axhmspd[HRTLTAX]=256
axhmspd[HRAZAX]=256
DM axspd[8];'Generic travel speed
axspd[GESAX]=7000;'16215;'seems ok
axspd[FLSINAX]=1024
axspd[FOCAX]=7000;'15000;'seems ok
axspd[FESINAX]=1024
axspd[FESELAX]=7000
axspd[LRTLTAX]=10000;'seems ok (w/o grating) Max per DS: 30091
axspd[HRTLTAX]=10000;'Max per DS: 5/6*5000um/s/0.078um/us=53418
axspd[HRAZAX]=10000;'Max per DS: 5/6*5000um/s/0.078um/us=53418
DM axmaxp[8];'Max possible position (steps, 16x microstepping)
axmaxp[GESAX]=288112;'Actual value slightly greater if overshooting limits
axmaxp[FLSINAX]=0
axmaxp[FOCAX]=16*200*180;'Infinite, about 1 revolution
axmaxp[FESINAX]=0;'about 10k
axmaxp[FESELAX]=0
axmaxp[LRTLTAX]=1126400; '1 revolution
axmaxp[HRTLTAX]=128205/2;'10mm
axmaxp[HRAZAX]=128205/2;'10mm
DM axminp[8];'Max possible position (steps, 16x microstepping)
axminp[GESAX]=0
axminp[FLSINAX]=0
axminp[FOCAX]=0
axminp[FESINAX]=0
axminp[FESELAX]=0
axminp[LRTLTAX]=0
axminp[HRTLTAX]=-128205/2;'10mm
axminp[HRAZAX]=-128205/2;'10mm

'delta of last move, maintained by/for #BACKLSH
DM ldelta[8]
ldelta[GESAX]=0;ldelta[FLSINAX]=0;ldelta[FOCAX]=0;ldelta[FESINAX]=0
ldelta[FESELAX]=0;ldelta[LRTLTAX]=0;ldelta[HRTLTAX]=0;ldelta[HRAZAX]=0


DM bcklsh[8];'backlash in steps, for reference
bcklsh[GESAX]=77;'76.2 microns
bcklsh[FLSINAX]=0
bcklsh[FOCAX]=18;'880 microradians (estimate based on LRTLT stage)
bcklsh[FESINAX]=55;' ABOUT 52-58
bcklsh[FESELAX]=0
bcklsh[LRTLTAX]=34;'200 microradians (34.48 usteps)
bcklsh[HRTLTAX]=128;'10 microns (128.2 usteps)
bcklsh[HRAZAX]=128;'10 microns (128.2 usteps)
DM mininc[8];'minimum incremental motion
mininc[GESAX]=0
mininc[FLSINAX]=0
mininc[FOCAX]=0
mininc[FESINAX]=0
mininc[FESELAX]=0;'<20 by touch
mininc[LRTLTAX]=4;'Per DS: 21 microradians = 3.62 us => 4 usteps = 23.2 urad
mininc[HRTLTAX]=13;'microsteps, 1 micron
mininc[HRAZAX]=13;'microsteps, 1 micron
'Unused, comented as short of array space
'DM dperus[8];'delta per microstep
'dperus[GESAX]=.992;'microns per microstep
'dperus[FLSINAX]=0
'dperus[FOCAX]=49.087;'microradians per microstep
'dperus[FESINAX]=0
'dperus[FESELAX]=0
'dperus[LRTLTAX]=5.8;'microradians per microstep
'dperus[HRTLTAX]=0.078;'microns per microstep
'dperus[HRAZAX]=0.078;'microns per microstep

'Encoder value near a limit, unused on unencoded
DM encnlim[8]
'Value strictly > -limit
' Got reading of 161 while on -lim.
' hard limit is at 49. 
' Noise on pot with motors off has a sigma of about 1.3 with on 80
encnlim[GESAX]=200
'Value strictly > -limit
' unknown, system not yet built TODO
encnlim[FESELAX]=0
'Value slightly before 4096-to-0 rollover
'unknown, NEED testing TODO (or remove if we aren't going to use CALFOC
encnlim[FOCAX]=3800


'Whether or not the axis is calibrated
DM axiscal[8]
axiscal[GESAX]=false;axiscal[FLSINAX]=false;axiscal[FOCAX]=false
axiscal[FESINAX]=false;axiscal[FESELAX]=false;axiscal[LRTLTAX]=false
axiscal[HRTLTAX]=false;axiscal[HRAZAX]=false


'Last error state of the axis
DM axiserr[8]
axiserr[GESAX]=ENONE;axiserr[FLSINAX]=ENONE;axiserr[FOCAX]=ENONE
axiserr[FESINAX]=ENONE;axiserr[FESELAX]=ENONE;axiserr[LRTLTAX]=ENONE
axiserr[HRTLTAX]=ENONE;axiserr[HRAZAX]=ENONE


'FOC related defines
focentol=5;' Encoder tolerance of a desired pot position TODO: DETERMINE


'GES Related Defines
geshrp=7400;'(steps) Position of HiRes mode from calibrated 0 TODO: finalize
geslrp=265000;'(steps) Position of LoRes mode from calibrated 0 TODO: finalize
gesgsp=1393;' GES Grating Swap position relative to calibrated 0 TODO: finalize
geshrep=285; 'GES HR encoder nominal position TODO: finalize
geslrep=3798; 'GES LR encoder nominal position ROUGH GUESS TODO: finalize
gesgsep=1397;' GES Grating Swap encoder nominal position TODO: finalize
'GES encoder nominal position tolerance 
gesenct=7;'1st GUESS:0.5mm/(300mm/4096) TODO: finalize

'HiRes Alt & Az defines
HRTLTLK=true;HRAZLK=true
LCKVOLT=2 ;'Determined empirically, > => locked 

'LoRes Tilt defines
lrthmos=6400;' Amount to overshoot home before creeping back 
' (ROUGH STAB TODO:refine)
lrtinpt=9 ;'  Digital in corresponding to the LoRes origin sensor
lrtinhx=$9
lrtathm=1 ;'  value of origin sensor (via @IN) when at home
lrhomng=false
lrswapp=-423000;' step position for lr grating swap

'Filter related defines
nfilt=8 ;' Number of filter slots
^a=nfilt+1;'Can't have expression within subscripts
'FES Elevator nominal filter position in steps
'.1" per rev 
felstpsp=16*200*5;'steps  worth of space between filters
DM feselfp[^a]
feselfp[0]=1500
feselfp[1]=feselfp[0]+felstpsp
feselfp[2]=feselfp[1]+felstpsp
feselfp[3]=feselfp[2]+felstpsp
feselfp[4]=feselfp[3]+felstpsp
feselfp[5]=feselfp[4]+felstpsp
feselfp[6]=feselfp[5]+felstpsp
feselfp[7]=feselfp[6]+felstpsp
feselfp[8]=feselfp[7]+16*200*28.5
'FES Elevator nominal filter position in encoder counts
felencsp=317;'.5" filter spacing, 317 counts measured ?? nominal
DM felencp[^a]
felencp[0]=4.2803
felencp[1]=felencp[0]+felencsp
felencp[2]=felencp[1]+felencsp
felencp[3]=felencp[2]+felencsp
felencp[4]=felencp[3]+felencsp
felencp[5]=felencp[4]+felencsp
felencp[6]=felencp[5]+felencsp
felencp[7]=felencp[6]+felencsp
felencp[8]=felencp[7]+1732;'Load position is an additional 2.85" further
'Allowable range (+/-) in encoder counts around nominal filter position
feselrg=2 ;'about 0.003"
fesinsp=64000 ;'The inserted position in steps of the FESIN arm
fesremp=0 ;'The removed position in steps of the FESIN arm
nearfilt=0;' nearest filter to current position, determined by QUFEL
allsafep=2746;'Encoder pos above which it is always safe to move the inserter

'FLS related defines
flsremp=0;'The removed position in steps of the FLSIN arm
flsinsp=64000;'The inserted position in steps of the FLSIN arm

'Set acceleration defaults
AC axaccel[0],axaccel[1],axaccel[2],axaccel[3]
AC ,,,,axaccel[4],axaccel[5],axaccel[6],axaccel[7]
'Set deceleration defaults
DC axdecel[0],axdecel[1],axdecel[2],axdecel[3]
DC ,,,,axdecel[4],axdecel[5],axdecel[6],axdecel[7]
'Set limit switch triggered deceleration
SD axdecel[0],axdecel[1],axdecel[2],axdecel[3]
SD ,,,,axdecel[4],axdecel[5],axdecel[6],axdecel[7]
'Set homing velocity defaults
HV axdecel[0],axdecel[1],axdecel[2],axdecel[3]
HV ,,,,axdecel[4],axdecel[5],axdecel[6],axdecel[7]

EN


'***************************************************************************
' Galil hardware config
'***************************************************************************
#M2FSCFG
ST;MC;MO*
'Set motor type, must be -2 or -2.5 per manual
MT -2.5,-2,-2.5,-2.5,-2,-2,-2.5,-2.5
KS*=1;'       Set step smoothing to Galil-recommended value, see AN#2446
AG 3,2,3,2,3,0,0,0;'              Set motor gain values
AQ1,4;AQ3,4;AQ5,4;AQ7,4;AQ8,4;'  GES,FOC,FESEL,HRTLT,HRAZ analog inputs: 0-10V
AF 1,,1,,1;'		Configure GES, FES, & FOC for analog feedback
YA 16,16,16,16,16,16,16,16;'Set stepping mode resolutions
YB 200,200,200,200,200,400,400,400;'Set stepper motor steps/revolution
LDE=3;'No limits on filter elevator
'Encoder resolution counts/rev (APPROXIMATE VALUES!)
'GES Nominally 44.7. GER R measured to be about 42.3
'FESEL measured to be 607.6 counts per inch on B side
YC 42,,26,,61 
'No built-in position error detection for steppers 	
ER*=-1			
'Configure: Limits active high, Home high -> go backward (retract)
'  to go home (needed by M228), Latch (Don't care), 
'  DI 4-7,12-15 axis specific aborts, Abort doesn't kill program
CN 1,-1,,1,1
CI 0
EN


'***************************************************************************
' Starutp Routine
'***************************************************************************
#AUTO
ST;MC;MO*
m2fsver=.1
HX1;HX2
bootup1=1
JS#M2FSCFG
JS#INIT
'Query the Filter elevator position to initialize nearfilt
JS#QUFELP
'Start monitor for pot jamming on GES and FESEL axes
REM ^a=GESAX;XQ#POTMON,1
REM ^a=FESELAX;XQ#POTMON,2
'Start the HIRes lock monitor
XQ #ANAMAF,1
XQ #LOCKMON,2
#IDLE;WT 10000;JP#IDLE
EN



'***************************************************************************
' CALibrate LoRes Tilt
' Calibrate the LoRes tilt
' Does not turn axis off if sucessful
' Returns ENONE iff sucessful
' Errors: ELRTSEN - home sensor failed
' assumes LoRes Axis is "F"
'***************************************************************************
#CALLRT
'Stack and XQ fancy footwork
JS#ZS;IF (_JS<1);JS#CALLRT;^h=_JS;ed4=_ED4;ret[ed4]=_JS;ELSE
'Axis F, Hope Success
^a=LRTLTAX;^h=ENONE
'Find home sensor if not there already
IF (@IN[lrtinpt]<>lrtathm)
II ,,lrtinhx,lrtinhx;'Trip on @IN[lrtinpt] goes to 1
lrhomng=true
'Do a relative move -1.1 revolutions
~a=^a;^b=-1.10*(axmaxp[^a]-axminp[^a])
~a=^a; AC~a=axaccel[^a]; DC~a=axdecel[^a]; SP~a=axspd[^a];PR~a=^b;SH~a; BG~a
' wait till stopped (input interrupt stopped us) or get to position
#CALLRT1;WT 500;JP#CALLRT1, (_SCF=0);~a=^a;MC~a
'If not stopped by ST in interrupt routine turn off and fail.
IF (_SCF<>4);~a=^a;MO~a;^h=EHMERR
ENDIF;ENDIF
'If all is well
IF (^h=ENONE)
'Continue on to move off the home sensor
^b=-lrthmos
~a=^a;AC~a=axaccel[^a];DC~a=axdecel[^a];SP~a=axspd[^a];PR~a=^b;SH~a;BG~a;MC~a
'Move to home sensor
lrhomng=true
^b=(1.1*lrthmos)+bcklsh[^a] 
~a=^a; DC~a=axdecel[^a]; SP~a=axhmspd[^a]; PR~a=^b;SH~a; BG~a
' wait till stopped (input interrupt stopped us) or get to position
#CALLRT2;WT 500;JP#CALLRT2, (_SCF=0);~a=^a;MC~a
'If not stopped by ST in interrupt routine turn off and fail
' else Define the new position as home
IF (_SCF<>4);~a=^a;MO~a;^h=EHMERR
ELSE;~a=^a;DP~a=0;axiscal[^a]=true;ldelta[^a]=^b
ENDIF
ENDIF
' Turn off input interrupt and store status
II 0,,,;axiserr[^a]=^h
ENDIF
EN ,,^h
'***************************************************************************
' INput change INTerrupt
' If LoRes Tilt is homing and the input is triggered then halt the motion and
'  SHF (this should mean that a MC trippoint on the axis is cleared.)
'  TODO call galil re this
'***************************************************************************
#ININT
IF ((lrhomng=true)&(@IN[lrtinpt]=lrtathm))
REM DCF=axdecel[5] This command is reported as not valid while running yet I can 
REM  execute it over serial w/o any problem TODO: CALL GALIL 
REM STF;SHF;lrhomng=false
STF;lrhomng=false;ENDIF
RI


'***************************************************************************
' Get LoRes TiLt position
'***************************************************************************
#GETLRTL
^a=LRTLTAX
'Error status
IF(axiserr[^a]<>ENONE);JS#ERRMSG(^a,axiserr[^a])
'Move in progress
ELSE; ~a=^a;IF(_TS~a & $80);MG "GETLRTL: MOVING"
'Not calibrated
ELSE; IF(axiscal[^a]<>true);MG "GETLRTL: UNCALIBRATED"
'report position
ELSE; ~a=^a; MG "GETLRTL:",_TD~a
ENDIF;ENDIF;ENDIF
EN


'***************************************************************************
' Set LoRes TiLt(angle)
' Set the lo res tilt angle
'***************************************************************************
#SETLRTL
'Stack and XQ fancy footwork
JS#ZS;IF (_JS<1);ed4=_ED4;JS#SETLRTL(a[ed4]);^h=_JS;ed4=_ED4;ret[ed4]=_JS;ELSE
^b=^a
^a=LRTLTAX
'Calibrate if not
IF (axiscal[^a]<>true);JS#CALLRT;^h=_JS;ENDIF
'If we are good to go, MOVE!
IF(^h=0);JS#FANCYMV(^a,^b);~a=^a;MC~a;~a=^a;MO~a;ENDIF
'Store status
axiserr[^a]=^h
ENDIF
EN,,^h


'***************************************************************************
' Get HiRes TiLt position
'***************************************************************************
#GETHRTL
^a=HRTLTAX;
'Error status
IF(axiserr[^a]<>ENONE);JS#ERRMSG(^a,axiserr[^a])
'Move in progress
ELSE; ~a=^a;IF(_TS~a & $80);MG "GETHRTL: MOVING"
'Not calibrated
ELSE; IF(axiscal[^a]<>true);MG "GETHRTL: UNCALIBRATED"
'report position
ELSE; ~a=^a; MG "GETHRTL:",_TD~a
ENDIF;ENDIF;ENDIF
EN


'***************************************************************************
' Set HiRes TiLt(steps)
' Set the hi res tilt angle
'***************************************************************************
#SETHRTL
'Stack and XQ fancy footwork
JS#ZS;IF (_JS<1);ed4=_ED4;JS#SETHRTL(a[ed4]);^h=_JS;ed4=_ED4;ret[ed4]=_JS;ELSE
^b=^a
^a=HRTLTAX
^h=0;'Hope success
'Make sure the axis isn't locked
IF(HRTLTLK=true);^h=ELCKERR;ENDIF
'If we are good to go, make sure commanded position is sane
IF(^h=0);JS#SANEPOS(^a,^b);IF(_JS<>true);^h=ECRAZY;ENDIF
'If we are good to go, but not calibrated, calibrate
IF ((^h=0)&(axiscal[^a]<>true));JS#CALHMAX(^a);^h=_JS;ENDIF
'If we are good to go, MOVE!
IF(^h=0);JS#FANCYMV(^a,^b);~a=^a;MC~a;~a=^a;MO~a;ENDIF
ENDIF
'Store status
axiserr[^a]=^h
ENDIF
EN,,^h


'***************************************************************************
' Calibrate HiRes Azimuth position
'***************************************************************************
#CALHRAZ;JS#CALHMAX(HRAZAX);EN


'***************************************************************************
' Get HiRes AZimuth position
'***************************************************************************
#GETHRAZ
^a=HRAZAX;
'Error status
IF(axiserr[^a]<>ENONE);JS#ERRMSG(^a,axiserr[^a])
'Move in progress
ELSE; ~a=^a;IF(_TS~a & $80);MG "GETHRAZ: MOVING"
'Not calibrated
ELSE; IF(axiscal[^a]<>true);MG "GETHRAZ: UNCALIBRATED"
'report position
ELSE; ~a=^a; MG "GETHRAZ:",_TD~a
ENDIF;ENDIF;ENDIF
EN


'***************************************************************************
' Set HiRes AZimuth(steps)
' Set the hi res azimuth position
'***************************************************************************
#SETHRAZ
'Stack and XQ fancy footwork
JS#ZS;IF (_JS<1);ed4=_ED4;JS#SETHRAZ(a[ed4]);^h=_JS;ed4=_ED4;ret[ed4]=_JS;ELSE
^b=^a
^a=HRAZAX
^h=0;'Hope success
'Make sure the axis isn't locked
IF(HRAZLK=true);^h=ELCKERR;ENDIF
'If we are good to go, make sure commanded position is sane
IF(^h=0);JS#SANEPOS(^a,^b);IF(_JS<>true);^h=ECRAZY;ENDIF
'If we are good to go, but not calibrated, calibrate
IF ((^h=0)&(axiscal[^a]<>true));JS#CALHMAX(^a);^h=_JS;ENDIF
'If we are good to go, MOVE!
IF(^h=0);JS#FANCYMV(^a,^b);~a=^a;MC~a;~a=^a;MO~a;ENDIF
ENDIF
'Store status
axiserr[^a]=^h
ENDIF
EN,,^h


'***************************************************************************
' Calibrate the GES Stage
' return value is in ret
'***************************************************************************
#CALGES
JS#CALENAX(GESAX);ed4=_ED4;ret[ed4]=_JS
EN


'***************************************************************************
' QUery GES Position
' returns hires, lores, unknown, intermd
' TODO sort out behavior for case where motor and pot disagree
'***************************************************************************
#QUGESP
^a=GESAX
'Move in progress
~a=^a;IF (_TS~a & $80);^h=moving
ELSE;IF(axiscal[^a]<>true);^h=unknown
ELSE
'Wait for filtered analog position to be clean
JS#WAITAMF(^a)
REM ^g step position
REM ^b encoder position
REM ^c step position is equal to geslrp
REM ^d encoder position is within tolerance of lores position
REM ^e step position is equal to geshrp
REM ^f encoder position is within tolerance of hires position
~a=^a;^g=_TD~a;^b=gesanap;^c=(^g=geslrp);^e=(^g=geshrp)
^d=( ((^b>(geslrep-gesenct) & (^b<(geslrep+gesenct)) )
^f=( ((^b>(geshrep-gesenct) & (^b<(geshrep+gesenct)) )
IF (^c & ^d);^h=lores
ELSE;IF (^e & ^f);^h=hires
ELSE;IF (((^d=0) & ^c) | (^e & (^f=0)));^h=EGESPMM;axiserr[^a]=^h
ELSE;^h=intermd;ENDIF
ENDIF;ENDIF;ENDIF;ENDIF
EN,,^h


'***************************************************************************
' Get GES
' Return the GES position
'***************************************************************************
#GETGES
^a=GESAX
'Determine status
~a=^a;IF (_TS~a & $80);^h=moving
ELSE;IF(axiscal[^a]<>true);^h=unknown
ELSE;IF(anapcln[^a]<>-1);^h=settle
ELSE
REM ^g step position
REM ^b encoder position
REM ^c step position is equal to geslrp
REM ^d encoder position is within tolerance of lores position
REM ^e step position is equal to geshrp
REM ^f encoder position is within tolerance of hires position
~a=^a;^g=_TD~a;^b=gesanap;^c=(^g=geslrp);^e=(^g=geshrp)
^d=( ((^b>(geslrep-gesenct) & (^b<(geslrep+gesenct)) )
^f=( ((^b>(geshrep-gesenct) & (^b<(geshrep+gesenct)) )
IF (^c & ^d);^h=lores
ELSE;IF (^e & ^f);^h=hires
ELSE;IF (((^d=0) & ^c) | (^e & (^f=0)));axiserr[^a]=EGESPMM
ELSE;^h=intermd
ENDIF;ENDIF;ENDIF
ENDIF;ENDIF;ENDIF
'Report status
IF(axiserr[^a]<>ENONE);JS#ERRMSG(^a,axiserr[^a])
ELSE
IF(^h=unknown);MG "GETGES: UNCALIBRATED";ENDIF
IF(^h=moving);~a=^a;MG "GETGES: MOVING",_TP~a,_TD~a;ENDIF
IF(^h=settle);~a=^a;MG "GETGES: SETTLING",gesanap,_TD~a;ENDIF
IF(^h=lores);~a=^a;MG "GETGES: LORES",gesanap,_TD~a;ENDIF
IF(^h=hires);~a=^a;MG "GETGES: HIRES",gesanap,_TD~a;ENDIF
IF(^h=lrswap);~a=^a;MG "GETGES: SWAP",gesanap,_TD~a;ENDIF
IF(^h=intermd);~a=^a;MG "GETGES: INTERMEDIATE",gesanap,_TD~a;ENDIF
ENDIF
EN


'***************************************************************************
' QUery GES Position (simple, ignore analog encoder)
' returns hires, lores, unknown, intermd
' TODO sort out behavior for case where motor and pot disagree
'***************************************************************************
#QUGESP2
^a=GESAX;~a=^a;^g=_TD~a
~a=^a;IF (_TS~a & $80);^h=moving
ELSE;IF(axiscal[^a]<>true);^h=unknown
ELSE;IF (^g=geslrp);^h=lores
ELSE;IF (^g=geshrp);^h=hires
ELSE;IF (^g=gesgsp);^h=lrswap
ELSE;^h=intermd
ENDIF;ENDIF;ENDIF;ENDIF;ENDIF
EN,,^h


'***************************************************************************
' Get GES (simple, ignore analog encoder)
' Return the GES position
'***************************************************************************
#GETGES2
^a=GESAX
'Determine status
~a=^a;IF (_TS~a & $80);^h=moving
ELSE;IF(axiscal[^a]<>true);^h=unknown
ELSE
REM ^g step position
~a=^a;^g=_TD~a
IF (^g=geslrp);^h=lores
ELSE;IF (^g=geshrp);^h=hires
ELSE;IF (^g=gesgsp);^h=lrswap
ELSE;^h=intermd
ENDIF;ENDIF;ENDIF;ENDIF;ENDIF
'Report status
IF(axiserr[^a]<>ENONE);JS#ERRMSG(^a,axiserr[^a])
ELSE
IF(^h=unknown);MG "GETGES: UNCALIBRATED";ENDIF
IF(^h=moving);~a=^a;MG "GETGES: MOVING",_TP~a,_TD~a;ENDIF
IF(^h=lores);~a=^a;MG "GETGES: LORES",gesanap,_TD~a;ENDIF
IF(^h=hires);~a=^a;MG "GETGES: HIRES",gesanap,_TD~a;ENDIF
IF(^h=lrswap);~a=^a;MG "GETGES: SWAP",gesanap,_TD~a;ENDIF
IF(^h=intermd);~a=^a;MG "GETGES: INTERMEDIATE",gesanap,_TD~a;ENDIF
ENDIF
EN




'***************************************************************************
' LoRes grating swap
'***************************************************************************
#LRSWAP
'Stack and XQ fancy footwork
JS#ZS;IF (_JS<1);JS#LRSWAP;ELSE
^h=ENONE;'      Hope for success
^a=LRTLTAX
'Calibrate if not
IF (axiscal[^a]<>true);JS#CALLRT;^h=_JS;ENDIF
'Calibrate if needed
^a=GESAX
IF(axiscal[^a]<>true);JS#CALENAX(^a);^h=^h | _JS;ENDIF
'If we are good to go, MOVE!
IF(^h=0)
JS#FANCYMV(LRTLTAX,lrswapp);JS#FANCYMV(GESAX,gesgsp)
^a=LRTLTAX;~a=^a;MC~a;~a=^a;MO~a
^a=GESAX;~a=^a;MC~a;~a=^a;MO~a
'Verify we are in an acceptable position
JS#QUGESP;IF (_JS<>lrswap);^h=EFAIL;ENDIF
ENDIF
'Store status
axiserr[^a]=^h
ENDIF
EN



'***************************************************************************
' HIgh RESolution mode
'***************************************************************************
#HIRES
'Stack and XQ fancy footwork
JS#ZS;IF (_JS<1);JS#HIRES;ELSE
^a=GESAX;^h=ENONE;'      Hope for success
'Calibrate if needed
IF(axiscal[^a]<>true);JS#CALENAX(^a);^h=_JS;ENDIF
'If all is well start moving to position
IF(^h=0);JS#FANCYMV(^a,geshrp);~a=^a;MC~a;~a=^a;MO~a
'Verify we are in an acceptable position
JS#QUGESP;IF (_JS<>hires);^h=EFAIL;ENDIF
ENDIF
'Store status
axiserr[^a]=^h
ENDIF
EN


'***************************************************************************
' LOw RESolution mode
'***************************************************************************
#LORES
'Stack and XQ fancy footwork
JS#ZS;IF (_JS<1);JS#LORES;ELSE
^a=GESAX;^h=ENONE;'      Hope for success
'Calibrate if needed
IF(axiscal[^a]<>true);JS#CALENAX(^a);^h=_JS;ENDIF
'If all is well start moving to position
IF(^h=0);JS#FANCYMV(^a,geslrp);~a=^a;MC~a;~a=^a;MO~a
'Verify we are in an acceptable position
JS#QUGESP;IF (_JS<>lores);^h=EFAIL;ENDIF
ENDIF
'Store status
axiserr[^a]=^h
ENDIF
EN


'***************************************************************************
' Get Focus Position
' Does not wait for analog value to stabilize
'***************************************************************************
#GETFOC
^a=FOCAX
'Error status
IF(axiserr[^a]<>ENONE);JS#ERRMSG(^a,axiserr[^a])
'Move in progress
ELSE; ~a=^a;IF(_TS~a & $80);MG "GETFOC: MOVING"
'Report position
ELSE; ~a=^a; MG "GETFOC:",focanap,_TD~a
ENDIF;ENDIF
EN


'***************************************************************************
' Calibrate FOCus
'TODO make sure the typical moves in this routine are not less than the mininc
'for the axis, also make sure that they are larg enough to overcome backlash
'***************************************************************************
#CALFOCU
^a=FOCAX
'First move to near the pot transition
'Wait for filtered analog position to be clean
JS#WAITAMF(^a)
^b=encnlim[^a]-focanap
JS#ENC2STP(^a,^b)
~a=^a;AC~a=axaccel[^a];DC~a=axdecel[^a];PR~a=_JS;SH~a;BG~a;MC~a
'Wait for filtered analog position to be clean
JS#WAITAMF(^a)
^b=focanap
'If the pot doesn't read within the tolerance of the desired value, fail
IF(@ABS[^b-encnlim[^a]]>focentol);^h=1
ELSE
'Figure out how far we need to move to pass the edge
^b=(4096-^b)+200;JS#ENC2STP(^a,^b)
'Now move further until the pot wraps around
~a=^a;AC~a=axaccel[^a];DC~a=axdecel[^a];PR~a=_JS;SH~a;BG~a
#CALFOC1;WT 50;~a=^a;JP#CALFOC1,(_TP~a>2048);IF(_SC~a=0);ST~a;ENDIF;MC~a
'If not stopped by the stop command the pot has failed
~a=^a;IF(_SC~a<>4);^h=1
ELSE
'Move slowly back until the pot rolls over 0-to-4096
~a=^a;AC~a=axaccel[^a];DC~a=axdecel[^a];PR~a=-_JS;SH~a;BG~a
#CALFOC2;WT 50;~a=^a;JP#CALFOC2,(_TP~a<2048);IF(_SC~a=0);ST~a;ENDIF;MC~a
'If not stopped by the stop command the pot has failed
~a=^a;IF(_SC~a<>4);^h=1
ELSE
'Define this position to correspond with 4096 encoder counts
'TODO consider using focanap instead of 4096, also consider that 4096 may not
'  correspond to one full revolution with the pot is configured correctly
'  since there is a dead region
JS#ENC2STP(^a,4096)
~a=^a;DP~a=_JS
axiscal[^a]=true
ldelta[^a]=-bcklsh[^a]
ENDIF;ENDIF;ENDIF
'Report status
IF(^h=1);JS#ERRMSG(^a,EFAIL)
ELSE;TODO REPORT STATUS MESSAGE, focanap & _TD~a
EN,,^h


'***************************************************************************
' Set FOC Position(Encoder position)
' ¿TODO? ADD in check for pot failure
'***************************************************************************
#SETFOC
'Stack and XQ fancy footwork
JS#ZS;IF(_JS<1);ed4=_ED4;JS#SETFOC(a[ed4]);^h=_JS;ed4=_ED4;ret[ed4]=_JS;ELSE
^b=^a
^a=FOCAX
MG "Requested p:",^b 
'Wait for filtered analog position to be clean
JS#WAITAMF(^a)
^b=^b-focanap
'MG "Counts to convert:",^b
JS#ENC2STP(^a,^b);~a=^a;^b=_TD~a+_JS
'MG "Moving to:",^b
~a=^a;JS#FANCYMV(^a,^b);~a=^a;MC~a;~a=^a;MO~a
ENDIF
EN

'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

'***************************************************************************
' GET FES Iserter status
' responds "IN" "OUT" "UNKNOWN" "INTERMEDIATE"
'***************************************************************************
#GETFESI
JS#QUINPOS(FESINAX,fesinsp,fesremp)
IF (_JS=out);MG "GETFLSI: OUT";ENDIF
IF (_JS=in);MG "GETFLSI: IN";ENDIF
IF (_JS=intermd);MG "GETFLSI: INTERMEDIATE";ENDIF
IF (_JS=unknown);MG "GETFLSI: UNKNOWN";ENDIF
EN

'***************************************************************************
' INsert FES INserter arm
'***************************************************************************
#INFESIN
'Stack and XQ fancy footwork
JS#ZS;IF (_JS<1);ed4=_ED4;JS#INFESIN(a[ed4]);^h=_JS;ed4=_ED4;ret[ed4]=_JS;ELSE
^h=0;^a=FESINAX;'          Hope for success
'Make sure the FESEL is in a safe position to insert filter
JS#FESELSF;^h=_JS
'Make sure we are calibrated
IF((^h=0)&(axiscal[^a]<>true));JS#CALINAX(^a);^h=_JS;ENDIF
'Insert FESIN if all is well
IF(^h=0);JS#FANCYMV(^a,fesinsp);~a=^a;MC~a;IF(_SC~a<>1);^h=1;ENDIF;MO~a;ENDIF
axiserr[^a]=^h
ENDIF
EN,,^h


'***************************************************************************
' ReMove FES INserter arm
'***************************************************************************
#RMFESIN
'Stack and XQ fancy footwork
JS#ZS;IF (_JS<1);ed4=_ED4;JS#RMFESIN(a[ed4]);^h=_JS;ed4=_ED4;ret[ed4]=_JS;ELSE
^h=0;^a=FESINAX;'          Hope for success
'Make sure the FESEL is in a safe position to remove filter
JS#FESELSF;^h=_JS
'Make sure we are calibrated
IF((^h=0)&(axiscal[^a]<>true));JS#CALINAX(^a);^h=_JS;ENDIF
'Remove the FESIN if all is well
JS#MOV2LIM(^a, axaccel[^a], axdecel[^a], -axspd[^a]);^h=_JS
'Move to the removed idle position
IF(^h=0);JS#FANCYMV(^a,fesremp);~a=^a;MC~a;IF(_SC~a<>1);^h=1;ENDIF;
~a=^a;MO~a
ENDIF
axiserr[^a]=^h
ENDIF
EN,,^h


'***************************************************************************
' FES ELevator SaFe
' Returns 0 if the elevator is in a safe position for the 
'  FESIN arm to move
' Cases:
'   caddy is above inserter or within tolerance of a filter position: return 0
'   caddy is in front of inserter, but not within tolerance of filter position
'    if the inserter position is == fesremp
'      nudge to the nearest filter
'      if within tolerance return true
'    fail
' If the elevator isn't is a safe position it attempts to move it to a safe
' position
'***************************************************************************
#FESELSF
'Stack and XQ fancy footwork
JS#ZS;IF (_JS<1);ed4=_ED4;JS#FESELSF(a[ed4]);^h=_JS;ed4=_ED4;ret[ed4]=_JS;ELSE
^a=FESELAX
'Hope for success
^h=0
JS#WAITAMF(^a)
'Case 1: caddy is above inserter return 0
IF(felanap>allsafep);^h=0;
ELSE
'Check if position is within tolerance of a filter position
JS#QUFELP;IF( (_JS>=filterp1) & (_JS<=filter8) );^h=0
ELSE
'We are in a position that needs fine tuning before it is safe to 
' move the FESIN arm, but it is only safe to tweak the position if the
' inserter position is known
JS#QUINPOS(FESINAX,fesinsp,fesremp)
IF (_JS<>out); ^h=1;axiserr[^a]=EFLTUNSF
ELSE
'Try to nudge elevator toward nearest valid position
'Compute number of steps between current encoder position and nominal 
' encoder position filter
JS#WAITAMF(^a)
^b=nearfilt-filterp1;'NB nearfilt is defermined by QUFELP
^b=felencp[^b]-felanap;'encoder distance to nearest filter pos
JS#ENC2STP(FESELAX,^b)
'Compute new desired position
~a=^a;^b=_TD~a+_JS
JS#FANCYMV(^a,^b);~a=^a;MC~a;MO~a
'Check the position again
JS#QUFELP
'If we still aren't in a safe spot fail
IF( ((_JS>=filterp1) & (_JS<=filter8)) | felanap>allsafep );^h=0
ELSE;^h=1;axiserr[^a]=EFLTUNSF
ENDIF;ENDIF;ENDIF;ENDIF;ENDIF
EN,,^h


'***************************************************************************
' QUery Filter ELevator Position
' returns moving, filterp1,...,filterp8, filterld, intermd
' Does not consider inserter arm status
'***************************************************************************
#QUFELP
^a=FESELAX
~a=^a;IF(_SC~a=0);^h=moving
ELSE
'Wait for filtered analog position to be clean
JS#WAITAMF(^a)
'Determine which filter is nearest current position 
'Compute abs(feselfp[i]-position)
^f=felanap
^d=@ABS[felencp[0]-^f];^e=0;^b=1
'find minumum ^e=iue of minimumndex of minimum ^d=val
#QUFELP1
^c=@ABS[felencp[^b]-^f]
IF (^c<^d);^d=^c;^e=^b;ENDIF;^b=^b+1
JP#QUFELP1,(^b<=nfilt)
'Store the nearest filter
nearfilt=^e+filterp1
'If minimum is < feselrg then we are in the position
IF(^d<feselrg)
'Convert ^e to the return value
^h=^e+filterp1
ELSE
'Not in position of a filter
^h=intermd
ENDIF
ENDIF
EN,,^h


'***************************************************************************
' GET FILTer
'   Report the current filter
'  Filter 1-8 In, Out?????TODO, None, Load, Moving, Intermediate
'***************************************************************************
#GETFILT
JS#QUINPOS(FESINAX,fesinsp,fesremp);^a=_JS
JS#QUFELP;^b=_JS
IF((^a=moving)|^b=moving);MG "GETFILT: Moving"
ELSE;IF(^b=filterld);MG "GETFILT: Load"
ELSE;IF(^a=unknown);MG "GETFILT: UNKNOWN"
ELSE;IF(^a=out);MG "GETFILT: None"
ELSE;IF((^a=intermd)|(^b=intermd);MG "GETFILT: Intermediate"
ELSE;'One will match
IF(^b=filterp1);MG "GETFILT: 1";ENDIF
IF(^b=filterp2);MG "GETFILT: 2";ENDIF
IF(^b=filterp3);MG "GETFILT: 3";ENDIF
IF(^b=filterp4);MG "GETFILT: 4";ENDIF
IF(^b=filterp5);MG "GETFILT: 5";ENDIF
IF(^b=filterp6);MG "GETFILT: 6";ENDIF
IF(^b=filterp7);MG "GETFILT: 7";ENDIF
IF(^b=filterp8);MG "GETFILT: 8";ENDIF
ENDIF;ENDIF;ENDIF;ENDIF;ENDIF
EN


'***************************************************************************
' Pick FILter(filternum)
' 1-10,
' 1-8= Filters 1-8
' 9  = load position
' 10 = no filter
' Forces filternum to be integer
'***************************************************************************
#PICKFIL
'Stack and XQ fancy footwork
JS#ZS;IF (_JS<1);ed4=_ED4;JS#PICKFIL(a[ed4]);^h=_JS;ed4=_ED4;ret[ed4]=_JS;ELSE
'Hope for success, force filternum to an integer
^h=0;^a=@INT[^a]-1
'Check for invalid filter id
IF ((^a<0)|(^a>9));^h=EBADFP;axiserr[FESELAX]=EBADFP
ELSE;'ID valid, get current state of elevator (^b) and inserter (^c)
JS#QUFELP;^b=_JS-filterp1;
JS#QUINPOS(FESINAX,fesinsp,fesremp);^c=_JS
'If the desired position = current position we are done
IF( ((^a=9)&(^c=out))|(((^c=in)|(^a=8))&(^b=^a)) );^h=0;axiserr[FESELAX]=ENONE
ELSE;'We are not in position
'Stow the FESIN arm, note REFESIN ensures safe to move 
JS#RMFESIN;^h=_JS;axiserr[FESELAX]=^h
IF ((^h=0)&(^a<>9));'Arm retracted, desired filter != none
'Move to the desired filter
JS#FANCYMV(FESELAX,feselfp[^a]);~a=FESELAX;MC~a;~a=FESELAX;MO~a
'Get current state of elevator
JS#QUFELP;^b=_JS
IF( ((^b-filterp1)=^a) & (^b<>intermd) );'If we are where we should be...
'Insert the filter if needed
IF(^b<>filterld);JS#INFESIN;^h=_JS;axiserr[FESELAX]=^h
ELSE;axiserr[FESELAX]=ENONE;ENDIF
ELSE;^h=EFLTUNSF;axiserr[FESELAX]=^h
ENDIF;ENDIF;ENDIF;ENDIF
ENDIF
EN,,^h



'***************************************************************************
' GET FLS Iserter status
' responds "IN" "OUT" "UNKNOWN" "INTERMEDIATE"
'***************************************************************************
#GETFLSI
JS#QUINPOS(FLSINAX,flsinsp,flsremp)
IF (_JS=out);MG "GETFLSI: OUT";ENDIF
IF (_JS=in);MG "GETFLSI: IN";ENDIF
IF (_JS=intermd);MG "GETFLSI: INTERMEDIATE";ENDIF
IF (_JS=unknown);MG "GETFLSI: UNKNOWN";ENDIF
EN


'***************************************************************************
' INsert FLS INserter arm
'***************************************************************************
#INFLSIN
^h=0;'          Hope for success
^a=FLSINAX
'Make sure we are calibrated
IF(axiscal[^a]<>true));JS#CALINAX(^a);^h=_JS;ENDIF
'Insert FLSIN if all is well
IF(^h=0)
JS#FANCYMV(^a,flsinsp);~a=^a;MC~a;IF(_SC~a<>1);^h=1;ENDIF;MO~a
ENDIF
'Handle status reporting, could be better
IF (^h=1);JS#ERRMSG(FLSINAX,EFAIL);ENDIF
EN,,^h


'***************************************************************************
' ReMove FLS INserter arm
' NB it is always safe to remove
'***************************************************************************
#RMFLSIN
^h=0;'          Hope for success
^a=FLSINAX
'Make sure we are calibrated
IF(axiscal[^a]<>true));JS#CALINAX(^a);^h=_JS;ENDIF
'Remove FLSIN if all is wellIF(^h=0)
JS#FANCYMV(^a,flsremp);~a=^a;MC~a;IF(_SC~a<>1);^h=1;ENDIF;MO~a
ENDIF
'Handle status reporting, could be better
IF (^h=1);JS#ERRMSG(FLSINAX,EFAIL);ENDIF
EN,,^h


'***************************************************************************
' CALibrate INserter AXis
'***************************************************************************
#CALINAX;'(axis)
'Stack and XQ fancy footwork
JS#ZS;IF (_JS<1);ed4=_ED4;JS#CALINAX(a[ed4]);^h=_JS;ed4=_ED4;ret[ed4]=_JS;ELSE
JS#MOV2LIM(^a, axaccel[^a], axdecel[^a], -axlmspd[^a]);^h=_JS
IF (^h=0)
~a=^a;MC~a;~a=^a;DP~a=0;axiscal[^a]=true;^h=0;ldelta[^a]=-10*bcklsh[^a]
ENDIF
'Store status
axiserr[^a]=^h
ENDIF
EN ,,^h


'***************************************************************************
' QUery INserter POSition status (AXIS, inserted step pos, removed step pos)
' returns: out, in, intermediate, or unknown (if uncalibrated)
'***************************************************************************
#QUINPOS;'(axis,insertedpos,removedpos)
'Uncalibrated
IF (axiscal[^a]<>true);^h=unknown
ELSE
'Stopped, out position
~a=^a;IF ((_SC~a=1) & (_TP~a=^c));^h=out
ELSE
'Stopped, in position
~a=^a;IF ((_SC~a=1) & (_TP~a=^b));^h=in
ELSE
'Stopped, somewhere else
~a=^a;IF (_SC~a<>0);^h=intermd
ELSE
'Moving
^h=moving
ENDIF;ENDIF;ENDIF;ENDIF
EN,,^h


'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
'+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

'***************************************************************************
' CALibrate HoMe-switched, unencoded AXis(axis)
' Calibrate an axis that has a home switch but no encoder
' If home switch fails then sends EHMERR
' Does not turn axis off if sucessful, 
' For use on axes w/o pot & with a Home switch (HRTLT,HRAZ,FLSIN?,FESIN?)
' Returns 0 iff sucessful
'***************************************************************************
#CALHMAX;'(axis)
'Stack and XQ fancy footwork
JS#ZS;IF (_JS<1);JS#CALHMAX(^a);^h=_JS;ELSE
JS#MOV2LIM(^a, axaccel[^a], axdecel[^a], -axlmspd[^a]);^h=_JS
IF (^h=0)
~a=^a;HV~a=axhmspd[^a];SP~a=axspd[^a];DC~a=axdecel[^a];SH~a;HM~a;BG~a
~a=^a;MC~a
'If we didn't stop because of homing then the home switch broke.
~a=^a;IF(_SC~a<>10);ST~a;MC~a;~a=^a;MO~a;^h=EHMERR
ELSE;'Define the new position as home
~a=^a;MC~a;~a=^a;DP~a=0;axiscal[^a]=true;^h=0;ldelta[^a]=-10*bcklsh[^a]
ENDIF
ENDIF
'Store status
axiserr[^a]=^h
ENDIF
EN ,,^h


'***************************************************************************
' CALibrate ENcoded AXis(axis)
' Calibrate an axis that has an analog encoder
' Does not turn axis off if sucessful, 
' For use on axes w/o pot & with a Home switch (GES, ¿FESEL?)
' Returns 0 iff sucessful
'***************************************************************************
#CALENAX
'Hope for success
^h=0
MG "Wait"
'Wait for filtered analog position to be clean
JS#WAITAMF(^a)
'If pot reads close to the negative limit move positive by a little
^b=analogp[^a]
IF(^b < encnlim[^a])
^b=1024;'5*(encnlim[^a]-^b)
JS#ENC2STP(^a,^b);~a=^a;AC~a=axaccel[^a]; DC~a=axdecel[^a];SP~a=axspd[^a]
MG "Pot reads close to the negative limit move positive by a little", ^b,_JS
~a=^a;PR~a=_JS;SH~a;BG~a;MC~a
ENDIF
MG "Wait"
'Wait for filtered analog position to be clean
JS#WAITAMF(^a)
'Overestimate distance to -limit
JS#ENC2STP(^a,analogp[^a]);^b=2*_JS
'Now start a move to past the -limit
MG "Overest dist to -lim and start a move to past limit",-^b
~a=^a;AC~a=axaccel[^a]; DC~a=axdecel[^a];SP~a=axlmspd[^a];PR~a=-^b;SH~a;BG~a
'Wait until stopped
#CALENA1;WT500;~a=^a;JP#CALENA1, (_SC~a=0);~a=^a;MC~a
'If we weren't stopped by the -limit, fail
~a=^a;IF(_SC~a<>3);^h=ELIMSWF
MG"Not stopped by -limit,fail."
ELSE
'If we somehow overshot limit move forward slowly until on limit
~a=^a;IF(_LR~a=1)
'Try to move back onto the limit
MG "Wait"
JS#WAITAMF(^a);JS#ENC2STP(^a,analogp[^a]);^b=1.1*_JS
MG "overshot limit move forward slowly until on limit",^b
~a=^a;SP~a=axhmspd[^a];PR~a=^b;BG~a
#CALENA2;WT 50;~a=^a;JP#CALENA2, (_LR~a=1);ST~a;MC~a
'If negative movement is allowed then the switch failed 
'  or we managed to overshoot twice it either way this is a fail
~a=^a;IF(_LR~a=1);^h=ELIMOST
MG "STILL NOT ON LIMIT, fail"
ENDIF
ENDIF
'If all is well
IF(^h=0)
'Get number of steps to position near limit and use it
'  to estimate steps needed to move totally off the negative limit
MG "wait"
JS#WAITAMF(^a);^b=encnlim[^a]-analogp[^a];JS#ENC2STP(^a,^b);^b=1.1*_JS
'Move off limit slowly and stop
MG "Move off limit slowly",^b
~a=^a;PR~a=^b;BG~a
#CALENA3;WT 50;~a=^a;JP#CALENA3, ((_LR~a=0) & (_SC~a=0));ST~a;MC~a
'If we didn't get off the limit, fail
~a=^a;IF(_LR~a=0);^h=ELIMSWF
MG "STILL ON LIMIT, fail"
ENDIF
ENDIF
ENDIF
'If success, make this the reference position
IF (^h=0)
MG "Calibrated axis",^a
JS#ZERSTP(^a);axiscal[^a]=true;ldelta[^a]=10*bcklsh[^a]
'TODO consider defining position based on pots value
ELSE
MG "Failed to calibrate axis",^a
~a=^a;MC~a;~a=^a;MO~a
ENDIF
'Store status
axiserr[^a]=^h
EN,,^h


'***************************************************************************
' Fancy MoVe(axis, position)
' Start a move to position on the specified axis, accounting for
'  both minimum incremental motion & backlash
'***************************************************************************
#FANCYMV;'(axis,absolute)
'Compute delta
^b=@RND[^b]
~a=^a;^c=^b-_TD~a
IF(^c<>0)
~a=^a;MG "FANCYMV: Move axis",^a," from",_TD~a," to",^b
'If required move is too small
IF(@ABS[^c]<mininc[^a])
MG "FANCYMV: Move is less than the minimum increment of",mininc[^a]
'First move mininc[^a]+@ABS[^c] in direction we last headed
IF(ldelta[^a]>0);~a=^a;^d=_TD~a+mininc[^a]+@ABS[^c]
ELSE;~a=^a;^d=_TD~a-mininc[^a]-@ABS[^c];ENDIF
~a=^a;AC~a=axaccel[^a];DC~a=axdecel[^a];SP~a=axlmspd[^a];PA~a=^d;SH~a;BG~a
~a=^a;MC~a
'Check position to see if we didn't reach our goal (i.e. we hit a limit)
~a=^a;IF(_TD~a<>^d)
'Figure how far we need to move in the other direction
IF(ldelta[^a]>0);~a=^a;^d=_TD~a-(2*(mininc[^a]+@ABS[^c]))
ELSE;~a=^a;^d=_TD~a+(2*(mininc[^a]+@ABS[^c]));ENDIF
'Compute delta
~a=^a;^e=^d-_TD~a
'Handle backlash
JS#BACKLSH(^a,^e)
'Move past in the other direction
~a=^a;AC~a=axaccel[^a];DC~a=axdecel[^a];SP~a=axlmspd[^a];PA~a=^d;SH~a;BG~a
~a=^a;MC~a
ENDIF
'Recompute delta
~a=^a;^c=^b-_TD~a
ENDIF
'Handle backlash
JS#BACKLSH(^a,^c)
'Start move to position
~a=^a;AC~a=axaccel[^a];DC~a=axdecel[^a];SP~a=axspd[^a];PA~a=^b;SH~a;BG~a;
ENDIF
EN


'***************************************************************************
' Move to limit (axis, acceleration, deceleration, velocity)
' Checks for stall by figuing the travel time for the entire extent of the axis
' If limit doesn't hit in allowed time the sends ELIMSWF
' velocity must not be 0
' Intended for uncalibrated use
'***************************************************************************
#MOV2LIM
REM These first two lines are problematic for the FLSIN & FESIM,
REM  if it becomes necessary to enable them
REM At present only the GES is physically capable of overshooting its limits
REM  If we didn't last stop because of the opposite limit
REM   move away from the limit we want be just a bit so account for having 
REM   potentially overshot it.
REM IF(^d>0);^e=-axlmos[^a];^f=3;ELSE;^e=axlmos[^a];^f=2;ENDIF;
REM ~a=^a;AC~a=^b; DC~a=^c;IF(_SC~a<>^f);PR~a=^e; BG~a;MC~a;ENDIF;
'If we are at the limit then we are done!
^h=ENONE;'Hope success
~a=^a;^f=(((_LR~a<>0)|(^d>0))&((_LF~a<>0)|(^d<0)))
~a=^a;MG ^a,^f,^d,_LR~a,_LF~a
IF(^f)
' when calibrated, we could tighten the move distance estimate
^e=(axmaxp[^a]-axminp[^a])*1.1
'Begin move (-limit if neg, +lim if pos) wait until limit or timeout
~a=^a;AC~a=^b;DC~a=^c;SP~a=^d;IF(^d>0);PR~a=^e;ELSE;PR~a=-^e;ENDIF;SH~a;BG~a
'Wait until we stop moving
#MOV2LI1;WT 100;~a=^a;JP#MOV2LI1, (_SC~a = 0);~a=^a;MC~a
'Determine the expected stop code & lest the last delta
IF(^d>0);ldelta[^a]=^e;^f=2;ELSE;ldelta[^a]=-^e;^f=3;ENDIF
'If the stop code is not that for the expected limit switch we failed
~a=^a;IF (_SC~a<>^f);MO~a;^h=ELIMSWF;ENDIF
ENDIF
'Store status
axiserr[^a]=^h
EN ,,^h


'***************************************************************************
' Direction Change Query (Axis,position delta/direction)
'***************************************************************************
#DIRCNGQ
EN,,(((ldelta[^a]<0)&(^b>0)) | ((ldelta[^a]>0)&(^b<0)))


'***************************************************************************
' Back LaSH correction(axis, position delta)
' Routine applies a backlash correction if direction change
'***************************************************************************
#BACKLSH
'Figure out if a change in direction
JS#DIRCNGQ(^a,^b)
IF(_JS=true)
'Correct for backlash by simply changing the current position
~a=^a;IF(^b>0);^c=_TD~a-bcklsh[^a];ELSE;^c=_TD~a+bcklsh[^a];ENDIF
JS#DPWAFE(^a,^c)
ENDIF
ldelta[^a]=^b
EN


'***************************************************************************
' Check Sanity(axis, position)
'  Return true if position is, potentially, physically realizeable.
'  False otherwise 
'***************************************************************************
#SANEPOS
EN,,((^b>=axminp[^a]) & (^b<=axmaxp[^a]))


'***************************************************************************
' ANAlog Moving Average Filter
' Locals:
'   ^a=index counter
'   ^b=filter size
'   ^c=filter size -1
'   ^d=running total for GES
'   ^e=running total for FESEL
'   ^f=running total for FOC
' Arrays:
'   gespacu, felpacu, focpacu Accumulator arrays for the average
' Output (GLOBAL):
'   gesanap  filtered GES position
'   felanap  filtered FESEL position
'   focanap  filtered FOC position
'   analogp[8]  filter analog positions for each axis, only the GES,FESEL, &
'            FOC axes are meaningful
'***************************************************************************
#ANAMAF
JS#ZS
IF (_JS<1);JS#ANAMAF
ELSE
^b=ANAMAFSZ;^c=^b-1
~a=GESAX;gesanap=_TP~a
~a=FESELAX;felanap=_TP~a
~a=FOCAX;focanap=_TP~a
^d=gesanap*^c;^e=felanap*^c;^f=focanap*^c
DA gespacu[0], felpacu[0], focpacu[0]
DM gespacu[^b], felpacu[^b], focpacu[^b]
REM Initialize array with analog encoder values
^a=0
#ANAMAF1
~a=GESAX;gespacu[^a]=_TP~a
~a=FESELAX;felpacu[^a]=_TP~a
~a=FOCAX;focpacu[^a]=_TP~a
^a=^a+1
JP#ANAMAF1,^a<^b
'#ANAMAF2 is the filter.  It takes the most recent reading,
'  tosses out the oldest reading, sums the values and takes an average.
^a=0;AT0
#ANAMAF2
'If axis is in motion, update the index of the most recent dirty value
~a=GESAX;IF(_TS~a & $80);anapcln[GESAX]=^a;ENDIF
~a=FOCAX;IF(_TS~a & $80);anapcln[FOCAX]=^a;ENDIF
~a=FESELAX;IF(_TS~a & $80);anapcln[FESELAX]=^a;ENDIF
'Current value
~a=GESAX;gespacu[^a]=_TP~a
~a=FESELAX;felpacu[^a]=_TP~a
~a=FOCAX;focpacu[^a]=_TP~a
'sum in current value and subract oldest value
^g=^a+1
^d=^d-gespacu[^g]+gespacu[^a]
^e=^e-felpacu[^g]+felpacu[^a]
^f=^f-focpacu[^g]+focpacu[^a]
'Store filtered readings
gesanap=^d/^c;felanap=^e/^c;focanap=^f/^c
analogp[GESAX]=gesanap;analogp[FESELAX]=felanap;analogp[FOCAX]=focanap
^a=^g
'See if the reading is clear of motion contamination
IF(anapcln[GESAX]=^a);anapcln[GESAX]=-1;ENDIF
IF(anapcln[FESELAX]=^a);anapcln[FESELAX]=-1;ENDIF
IF(anapcln[FOCAX]=^a);anapcln[FOCAX]=-1;ENDIF
'If last read then subtract first array element and reset ^a
'MG TIME-^g
AT-1;JP#ANAMAF2,^a<^c
'If axis is in motion, update the index of the most recent dirty value
~a=GESAX;IF(_TS~a & $80);anapcln[GESAX]=^a;ENDIF
~a=FOCAX;IF(_TS~a & $80);anapcln[FOCAX]=^a;ENDIF
~a=FESELAX;IF(_TS~a & $80);anapcln[FESELAX]=^a;ENDIF
'Current value
~a=GESAX;gespacu[^a]=_TP~a
~a=FESELAX;felpacu[^a]=_TP~a
~a=FOCAX;focpacu[^a]=_TP~a;
'sum in current value and subract oldest value
^d=^d-gespacu[0]+gespacu[^a]
^e=^e-felpacu[0]+felpacu[^a]
^f=^f-focpacu[0]+focpacu[^a]
'Store filtered readings
gesanap=^d/^c;felanap=^e/^c;focanap=^f/^c
analogp[GESAX]=gesanap;analogp[FESELAX]=felanap;analogp[FOCAX]=focanap
^a=0
'See if the reading is clear of motion contamination
IF(anapcln[GESAX]=^a);anapcln[GESAX]=-1;ENDIF
IF(anapcln[FESELAX]=^a);anapcln[FESELAX]=-1;ENDIF
IF(anapcln[FOCAX]=^a);anapcln[FOCAX]=-1;ENDIF
'MG TIME-^h,gesanap,felanap,focanap
AT-1;JP#ANAMAF2
ENDIF
EN


'***************************************************************************
' WAITAMF(axis) Wait for the analog moving average filter to refresh for
'  the specified axis
'***************************************************************************
#WAITAMF
IF (anapcln[^a]<>-1)
MG "Waiting...";^b=TIME
#WAITAM1;WT200;JP#WAITAM1,(anapcln[^a]<>-1)
^c=TIME-^b;MG ^c," ms."
ENDIF
EN


'***************************************************************************
' ZERO ARRay
' Zeros the contents of the array
'***************************************************************************
#ZEROARR;^b=^a[-1];^c=0
#ZEROAR1;^a[^c]=0;^c=^c+1;JP#ZEROAR1,(^c<^b);EN


'***************************************************************************
' Mean of an ARRay
'***************************************************************************
#MEANARR
^b=^a[-1];^c=0;^d=0
#MEANAR1;^d=^d+^a[^c];^c=^c+1;JP#MEANAR1,(^c<^b)
EN,,^d/^b


'***************************************************************************
' Standard Deviation of an array, must pass mean as arg 2
'***************************************************************************
#STDDEV
^c=^a[-1];^d=0;^e=0
#STDDEV1;^g=^a[^d]-^b;^e=^e+(^g*^g);^d=^d+1;JP#STDDEV1,(^d<^c)
EN,,@SQR[^e/^c]


'***************************************************************************
' Tell Switch status
'***************************************************************************
#TELLTS;
^b=_TS~a;MG "Axis ",~a
IF (^b & $80);MG "In motion";ELSE;MG "Stopped";ENDIF
IF (^b & $40);MG "Axis error exceeds error limit";ENDIF
IF (^b & $20);MG "Motor Off";ELSE;MG "Motor On";ENDIF
IF (^b & $08);NO;ELSE;MG "Forward Limit Tripped";ENDIF
IF (^b & $04);NO;ELSE;MG "Reverse Limit Tripped";ENDIF
IF (^b & $02);MG "Home 1";ELSE;MG "Home 0";ENDIF
IF (^b & $01);MG "Axis Latched";ENDIF
IF (@IN[~a-60]) ;MG "Axis Abort 1";ELSE;MG "Axis Abort 0";ENDIF
EN


'***************************************************************************
' ZERo STePper counts(axis)
'   Zeros the stepper counts for axis, at current position, 
'  regardless of analog feedback status, preserves AF
' Define Position With Analog Feedback Enabled(axis,position)
'***************************************************************************
#ZERSTP;^b=0
#DPWAFE
~a=^a;^g=_AF~a;AF~a=0
IF(^a=GESAX);~a=^a;DP~a=^b;rstpm[GESPM]=1
ELSE;IF(^a=FESELAX);~a=^a;DP~a=^b;rstpm[FESELPM]=1
ELSE;~a=^a;DP~a=^b;ENDIF;ENDIF
~a=^a;AF~a=^g;
EN


'***************************************************************************
' ENCoder counts to STePs(axis, counts) 
'***************************************************************************
#ENC2STP
MG "Counts: ",^b
~a=^a;^h=(^b*_YA~a*_YB~a)/_YC~a
MG "To Steps: ",^h
EN,,^h


'***************************************************************************
' STePs to ENCoder counts(axis, steps) 
'***************************************************************************
#STP2ENC
~a=^a;^h=(^b*_YC~a)/(_YA~a*_YB~a)
EN,,^h


'***************************************************************************
' MOVTIME(dist,speed,accel,decel)
' Compute the time travel would theoretically take in units of the RTC
'***************************************************************************
#MOVTIME
REMa=^a;b=^b;c=^c;d=^d
REMMG "Move Time:",^a,^b,^c,^d
EN,,(@ABS[^a/^b]+(0.5*@ABS[(^b/^c)+(^b/^d)]))*(1000000/_TM)


'***************************************************************************
' Lock Monitor
' Monitors the axis locks for the HiRes stage
'***************************************************************************
#LOCKMON
IF(@AN[7] > LCKVOLT);HRTLTLK=true;ELSE;HRTLTLK=false;ENDIF
IF(@AN[8] > LCKVOLT);HRAZLK=true;ELSE;HRAZLK=false;ENDIF
WT 1000;JP#LOCKMON
EN


'***************************************************************************
' POTentiometer MONitor(axis)
' Check to see if the steps changed more (within reason) than the pot 
'  did every 100 ms
'   If so then Halt motion as the pot may be jammed
'   when a monitored axis has its steps reset one must also set
'   rstpm[GESPM]=true or rstpm[FESELPM]=true 
'  ^a=axis ^b=oldpot ^c=oldstep ^d=newpot  ^e=newstep
'  ^f=disagreement in pot v steps
'  ^h=delta pot ^g=delta step 
'***************************************************************************
#POTMON
AT0;
~a=^a;^b=_TP~a; ^c=_TD~a
#POTCHK1
IF((rstpm[GESPM]=true)&(^a=GESAX))
 ~a=^a;^c=0;^e=0;^b=_TP~a;^d=_TP~a;rstpm[GESPM]=false;' Reset old and new
ENDIF
IF((rstpm[FESELPM]=true)&(^a=FESELAX))
 ~a=^a;^c=0;^e=0;^b=_TP~a;^d=_TP~a;rstpm[GESPM]=false;' Reset old and new
ENDIF
~a=^a;^d=_TP~a; ^e=_TD~a
^h=^d  - ^b
^g=^e - ^c
^c=^e; ^b=^d
~a=^a;^f=@ABS[^h*(_YB*_YA~a)/_YC~a-^g]
IF(^f>error);DC~a=axdecel[^a];ST~a;MC~a;MO~a;potStat[^a]=potjam
JS#ERRMSG(^a,EPOTJAM,dpot,dstep,error)
ENDIF;
AT-250;JP #POTCHK1;'        Check again in a few ms
EN


'***************************************************************************
' ERRor MeSsaGe(axis, error,...)
'  Reports the specified error
'***************************************************************************
#ERRMSG
IF (^a=GESAX)
IF (^b=ENONE);MG "OK"
ELSE;IF (^b=EPOTJAM);MG "!GES: Pot not changing with steps."
ELSE;IF (^b=ELIMSWF);MG "!GES: Limit switch failure."
ELSE;IF (^b=EGESPMM)
MG "!GES: Encoder & stepper mismatch. Try recalibrating.",gesanap,_TDA
ELSE;IF (^b=EFAIL)
MG "!GES: Unspecified error. GES Pos:",gesanap," counts,",_TDA," steps"
ELSE;IF (^b=ECRAZY);MG "!GES: Requested value out of allowed range."
ELSE;IF (^b=ELIMOST);MG "!GES: Overshot limit switch."
ELSE;MG "!GES: Unknown error code",^b,". This is a software bug."
ENDIF;ENDIF;ENDIF;ENDIF;ENDIF;ENDIF;ENDIF
ENDIF
IF (^a=HRTLTAX)
IF (^b=ENONE);MG "OK"
ELSE;IF (^b=EHMERR);MG "!HRTLT: Homing failure. Switch did not toggle."
ELSE;IF (^b=ELIMSWF);MG "!HRTLT: Limit switch failure."
ELSE;IF (^b=ELCKERR);MG "!HRTLT: Locked. You must loosen the locking nut."
ELSE;IF (^b=ECRAZY);MG "!HRTLT: Requested value out of allowed range."
ELSE;IF (^b=EFAIL);MG "!HRTLT: Unspecified error."
ELSE;MG "!HRTLT: Unknown error code",^b,". This is a software bug."
ENDIF;ENDIF;ENDIF;ENDIF;ENDIF;ENDIF
ENDIF
IF (^a=HRAZAX)
IF (^b=ENONE);MG "OK"
ELSE;IF (^b=EHMERR);MG "!HRAZ: Homing failure. Switch did not toggle."
ELSE;IF (^b=ELIMSWF);MG "!HRAZ: Limit switch failure."
ELSE;IF (^b=ELCKERR);MG "!HRAZ: Locked. You must loosen the locking nut."
ELSE;IF (^b=ECRAZY);MG "!HRAZ: Requested value out of allowed range."
ELSE;IF (^b=EFAIL);MG "!HRAZ: Unspecified error."
ELSE;MG "!HRAZ: Unknown error code",^b,". This is a software bug."
ENDIF;ENDIF;ENDIF;ENDIF;ENDIF;ENDIF
ENDIF
IF (^a=LRTLTAX)
IF (^b=ENONE);MG "OK"
ELSE;IF (^b=EHMERR);MG "!LRTLT: Homing failure. Switch did not toggle."
ELSE;IF (^b=ECRAZY);MG "!LRTLT: Requested value out of allowed range."
ELSE;IF (^b=EFAIL);MG "!LRTLT: Unspecified error."
ELSE;MG "!LRTLT: Unknown error code",^b,". This is a software bug."
ENDIF;ENDIF;ENDIF;ENDIF
ENDIF
IF (^a=FOCAX)
IF (^b=ENONE);MG "OK"
ELSE;IF (^b=ECRAZY);MG "!FOC: Requested value out of allowed range."
ELSE;IF (^b=EFAIL);MG "!FOC: Unspecified error."
ELSE;MG "!FOC: Unknown error code",^b,". This is a software bug."
ENDIF;ENDIF;ENDIF
ENDIF
IF (^a=FLSINAX)
IF (^b=ENONE);MG "OK"
ELSE;IF (^b=ELIMSWF);MG "!FLSIN: Limit switch failure."
ELSE;IF (^b=EHMERR);MG "!FLSIN: Homing failure. Switch did not toggle."
ELSE;IF (^b=ECRAZY);MG "!FLSIN: Requested value out of allowed range."
ELSE;IF (^b=EFAIL);MG "!FLSIN: Unspecified error."
ELSE;MG "!FLSIN: Unknown error code",^b,". This is a software bug."
ENDIF;ENDIF;ENDIF;ENDIF;ENDIF
ENDIF
IF (^a=FESINAX)
IF (^b=ENONE);MG "OK"
ELSE;IF (^b=ELIMSWF);MG "!FESIN: Limit switch failure."
ELSE;IF (^b=EHMERR);MG "!FESIN: Homing failure. Switch did not toggle."
ELSE;IF (^b=ECRAZY);MG "!FESIN: Requested value out of allowed range."
ELSE;IF (^b=EFAIL);MG "!FESIN: Unspecified error."
ELSE;MG "!FESIN: Unknown error code",^b,". This is a software bug."
ENDIF;ENDIF;ENDIF;ENDIF;ENDIF
ENDIF
IF (^a=FESELAX)
IF (^b=ENONE);MG "OK"
ELSE;IF (^b=EPOTJAM);MG "!FESEL: Pot not changing with steps."
ELSE;IF (^b=ELIMSWF);MG "!FESEL: Limit switch failure."
ELSE;IF (^b=EHMERR);MG "!FESEL: Homing failure. Switch did not toggle."
ELSE;IF (^b=EBADFP);MG "!FESEL: ",^c," is not a valid filter position."
ELSE;IF (^b=ECRAZY);MG "!FESEL: Requested value out of allowed range."
ELSE;IF (^b=EFAIL);MG "!FESEL: Unspecified error."
ELSE;IF (^b=EFLTUNSF);MG "!FESEL: Filter changer unsafe state. Fix Manually."
ELSE;MG "!FESEL: Unknown error code",^b,". This is a software bug."
ENDIF;ENDIF;ENDIF;ENDIF;ENDIF;ENDIF;ENDIF;ENDIF
ENDIF
axiserr[^a]=ENONE
EN


'***************************************************************************
' Tell Amplifier status
'***************************************************************************
#TELLTA
^a=_TA0
IF (^a & $10);MG "Over Current (E-H Axes)";ENDIF
IF (^a & $1);MG "Over Current (A-D Axes)";ENDIF
^a=_TA3
IF (^a & $2);MG "ELO Active (E-H Axes)";ENDIF
IF (^a & $1);MG "ELO Active (A-D Axes)";ENDIF
EN


'***************************************************************************
' Command Error Interrupt
' Routine executed whenever a program error occurs
'***************************************************************************
#CMDERR
MG "Threads active:",_HX0,_HX1,_HX2,_HX3,_HX4,_HX5,_HX6,_HX7
MG "!CMDERR (thread",_ED1," line",_ED,"):";TC1
EN


#RUNNIN;MG "Active Threads",_HX0,_HX1,_HX2,_HX3,_HX4,_HX5,_HX6,_HX7;EN

'***************************************************************************
' ZS
' Returns the stack level of the calling subtoutine
'***************************************************************************
#ZS
IF(_ED4=0);zs=_ZS0;ENDIF
IF(_ED4=1);zs=_ZS1;ENDIF
IF(_ED4=2);zs=_ZS2;ENDIF
IF(_ED4=3);zs=_ZS3;ENDIF
IF(_ED4=4);zs=_ZS4;ENDIF
IF(_ED4=5);zs=_ZS5;ENDIF
IF(_ED4=6);zs=_ZS6;ENDIF
IF(_ED4=7);zs=_ZS7;ENDIF
EN,,zs-1
