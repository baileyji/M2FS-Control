REM ISR routines (e.g. ININT) always interrupt thread 0.
REM If a limit caused deceleration at SD rate and a ST 
REM   is issued the deceleration rate is not changed.
REM ST changes the stop code even if an axis is already stopped.
REM It appears that ^a, etc only get pushed onto the stack from the 2nd level down
REM also, it does not appear there is a way to use introspection to determine 
REM what stack depth a function is at
'***************************************************************************
' Initial Configuration
'***************************************************************************
#INIT
ST;MC;MO*

REM Defines
REM None of these should ever need to change and in fact changing WILL cause
REM bizarre and bad behavior!
REM For parameters look lower to the Parameters section.

GESAX=0
FLSINAX=1
FOCAX=2
FESINAX=3
FESELAX=4
LRTLTAX=5
HRTLTAX=6
HRAZAX=7

'Logic States
true=1;false=0

ENONE=0;'All is well
ETIME=1;
EHMERR=3;'HoMeingERRor
EPOTJAM=4;'POTJAMmed
ELIMSWF=5;'LIMitSWitchFail
ELCKERR=6;'LockError
EBADFP=7;'BADFilterPos
EGESPMM=8;'GESPotMotorMismatch
EFAIL=9
ECRAZY=11;'A passed parameter is outside of all sane bounds
ELIMOST=12;' Over shot the limitswitch
EFLTUNSF=13

'Array of threaded execution parameters
DM a[8],b[8],c[8],d[8],e[8],f[8],g[8],h[8],ret[8]
a[0]=0;a[1]=0;a[2]=0;a[3]=0;a[4]=0;a[5]=0;a[6]=0;a[7]=0
b[0]=0;b[1]=0;b[2]=0;b[3]=0;b[4]=0;b[5]=0;b[6]=0;b[7]=0
c[0]=0;c[1]=0;c[2]=0;c[3]=0;c[4]=0;c[5]=0;c[6]=0;c[7]=0
d[0]=0;d[1]=0;d[2]=0;d[3]=0;d[4]=0;d[5]=0;d[6]=0;d[7]=0
e[0]=0;e[1]=0;e[2]=0;e[3]=0;e[4]=0;e[5]=0;e[6]=0;e[7]=0
f[0]=0;f[1]=0;f[2]=0;f[3]=0;f[4]=0;f[5]=0;f[6]=0;f[7]=0
g[0]=0;g[1]=0;g[2]=0;g[3]=0;g[4]=0;g[5]=0;g[6]=0;g[7]=0
h[0]=0;h[1]=0;h[2]=0;h[3]=0;h[4]=0;h[5]=0;h[6]=0;h[7]=0
ret[0]=0;ret[1]=0;ret[2]=0;ret[3]=0;ret[4]=0;ret[5]=0;ret[6]=0;ret[7]=0

'Delta of last move, maintained by #BACKLSH
DM ldelta[8]
ldelta[GESAX]=0;ldelta[FLSINAX]=0;ldelta[FOCAX]=0;ldelta[FESINAX]=0
ldelta[FESELAX]=0;ldelta[LRTLTAX]=0;ldelta[HRTLTAX]=0;ldelta[HRAZAX]=0

'Possible Axis positions
out=0
in=1
moving=2
intermd=3
unknown=4
lores=5
hires=6
settle=7
lrswap=8
filterp1=9;'rest of filter position enums are set programatically
REM Aditional position defines must start at filterld+1
filterp2=filterp1+1;filterp3=filterp1+2;filterp4=filterp1+3;filterp5=filterp1+4
filterp6=filterp1+5;filterp7=filterp1+6;filterp8=filterp1+7;filterld=filterp1+8

'Pot monitoring
potjam=1
'Value must be set to 1 atomically when zeroing the position of an encoded axis
GESPM=0;FESELPM=1;DM rstpm[2];rstpm[GESPM]=false;rstpm[FESELPM]=false

nearfilt=0;' nearest filter to current position, determined by QUFEL

'Whether or not the axis is calibrated
DM axiscal[8]
axiscal[GESAX]=false;axiscal[FLSINAX]=false;axiscal[FOCAX]=false
axiscal[FESINAX]=false;axiscal[FESELAX]=false;axiscal[LRTLTAX]=false
axiscal[HRTLTAX]=false;axiscal[HRAZAX]=false

'Last error state of the axis
DM axiserr[8]
axiserr[GESAX]=ENONE;axiserr[FLSINAX]=ENONE;axiserr[FOCAX]=ENONE
axiserr[FESINAX]=ENONE;axiserr[FESELAX]=ENONE;axiserr[LRTLTAX]=ENONE
axiserr[HRTLTAX]=ENONE;axiserr[HRAZAX]=ENONE

'Analog Filter Arrays
DM analogp[8]
DM anapcln[8];'-1 if no motion has occured within filter window
~a=GESAX;gesanap=_TP~a;analogp[GESAX]=gesanap
~a=FOCAX;focanap=_TP~a;analogp[FOCAX]=focanap
~a=FESELAX;felanap=_TP~a;analogp[FESELAX]=felanap
anapcln[GESAX]=-1;anapcln[FOCAX]=-1;anapcln[FESELAX]=-1



REM Parameters
REM Absolutly do not consider a value final unless it has a comment!
REM  (or the instrument is on the telescope and in use, then Mea Culpa -JB)


'Analog Position Filtering
ANAMAFSZ=1000;'Filter sample size (filter should run at 1ms intervals)


DM axaccel[8];'Generic Acceleration rate
axaccel[GESAX]=100000
axaccel[FLSINAX]=256000
axaccel[FOCAX]=100000
axaccel[FESINAX]=256000
axaccel[FESELAX]=256000
axaccel[LRTLTAX]=100000
axaccel[HRTLTAX]=100000
axaccel[HRAZAX]=100000

DM axdecel[8];'Generic Deceleration rate
axdecel[GESAX]=100000
axdecel[FLSINAX]=256000
axdecel[FOCAX]=100000
axdecel[FESINAX]=256000
axdecel[FESELAX]=256000
axdecel[LRTLTAX]=190000
axdecel[HRTLTAX]=160000;'5/6 * 15000um/s^2/0.078um/us=160256
axdecel[HRAZAX]=160000;'5/6 * 15000um/s^2/0.078um/us=160256

DM axlmspd[8];'limit speed (speed used when intentionally moving to a limit)
axlmspd[GESAX]=6400
axlmspd[FLSINAX]=1024
axlmspd[FOCAX]=6400;'unused
axlmspd[FESINAX]=1024
axlmspd[FESELAX]=6400
axlmspd[LRTLTAX]=6400;'unused
axlmspd[HRTLTAX]=6400
axlmspd[HRAZAX]=6400
REM NB The PI actuators advise no greater than 10% max speed
REM    when approaching limits.

DM axhmspd[8];'homing speed, used when returning to home after overshoot
axhmspd[GESAX]=256
axhmspd[FLSINAX]=256
axhmspd[FOCAX]=256
axhmspd[FESINAX]=256
axhmspd[FESELAX]=256
axhmspd[LRTLTAX]=256
axhmspd[HRTLTAX]=256
axhmspd[HRAZAX]=256

DM axspd[8];'Generic travel speed
axspd[GESAX]=7000;'16215;'seems ok
axspd[FLSINAX]=1024
axspd[FOCAX]=7000;'15000;'seems ok
axspd[FESINAX]=1024
axspd[FESELAX]=7000
axspd[LRTLTAX]=10000;'seems ok (w/o grating) Max per DS: 30091
axspd[HRTLTAX]=10000;'Max per DS: 5/6*5000um/s/0.078um/us=53418
axspd[HRAZAX]=10000;'Max per DS: 5/6*5000um/s/0.078um/us=53418

DM axmaxp[8];'Max possible position (steps, 16x microstepping)
axmaxp[GESAX]=288112;'Actual value slightly greater if overshooting limits
axmaxp[FLSINAX]=6447;'Determined experimentally
axmaxp[FOCAX]=16*200*180;'Infinite, about 1 revolution
axmaxp[FESINAX]=9413;'Determined experimentally, B Side
axmaxp[FESELAX]=210000;'Determined experimentally, B Side
axmaxp[LRTLTAX]=1126400; '1 revolution
axmaxp[HRTLTAX]=128205/2;'10mm
axmaxp[HRAZAX]=128205/2;'10mm

DM axminp[8];'Max possible position (steps, 16x microstepping)
axminp[GESAX]=0
axminp[FLSINAX]=0
axminp[FOCAX]=0
axminp[FESINAX]=0
axminp[FESELAX]=0
axminp[LRTLTAX]=0
axminp[HRTLTAX]=-128205/2;'10mm
axminp[HRAZAX]=-128205/2;'10mm

DM bcklsh[8];'backlash in steps, for reference
bcklsh[GESAX]=77;'76.2 microns
bcklsh[FLSINAX]=15;'Determined experimentally
bcklsh[FOCAX]=18;'880 microradians (estimate based on LRTLT stage)
bcklsh[FESINAX]=55;' ABOUT 52-58
bcklsh[FESELAX]=15;'Determined experimentally
bcklsh[LRTLTAX]=34;'200 microradians (34.48 usteps)
bcklsh[HRTLTAX]=128;'10 microns (128.2 usteps)
bcklsh[HRAZAX]=128;'10 microns (128.2 usteps)

DM mininc[8];'minimum incremental motion
mininc[GESAX]=0
mininc[FLSINAX]=0
mininc[FOCAX]=0
mininc[FESINAX]=0
mininc[FESELAX]=0;'<20 by touch
mininc[LRTLTAX]=4;'Per DS: 21 microradians = 3.62 us => 4 usteps = 23.2 urad
mininc[HRTLTAX]=13;'microsteps, 1 micron
mininc[HRAZAX]=13;'microsteps, 1 micron

'Unused, comented as short of array space
'DM dperus[8];'delta per microstep
'dperus[GESAX]=.992;'microns per microstep
'dperus[FLSINAX]=0
'dperus[FOCAX]=49.087;'microradians per microstep
'dperus[FESINAX]=0
'dperus[FESELAX]=0
'dperus[LRTLTAX]=5.8;'microradians per microstep
'dperus[HRTLTAX]=0.078;'microns per microstep
'dperus[HRAZAX]=0.078;'microns per microstep

'Encoder value near a limit, unused on unencoded. Value strictly > -limit
DM encnlim[8]
' GES reading of 161 while on -lim, hardstop at 49. 
encnlim[GESAX]=200
encnlim[FESELAX]=0
'Value slightly before 4096-to-0 rollover
'unknown, NEED testing TODO (or remove if we aren't going to use CALFOC
encnlim[FOCAX]=3800

'FOC related defines
focentol=5;' Encoder tolerance of a desired pot position TODO: DETERMINE

'GES Related Defines
geshrp=7400;'(steps) Position of HiRes mode from calibrated 0 TODO: finalize
geslrp=265000;'(steps) Position of LoRes mode from calibrated 0 TODO: finalize
gesgsp=1393;' GES Grating Swap position relative to calibrated 0 TODO: finalize
geshrep=285; 'GES HR encoder nominal position TODO: finalize
geslrep=3798; 'GES LR encoder nominal position ROUGH GUESS TODO: finalize
gesgsep=1397;' GES Grating Swap encoder nominal position TODO: finalize
'GES encoder nominal position tolerance 
gesenct=7;'1st GUESS:0.5mm/(300mm/4096) TODO: finalize

'HiRes Alt & Az defines
HRTLTLK=true;HRAZLK=true;'Start assuming locked
LCKVOLT=2 ;'Determined empirically, > => locked 

'LoRes Tilt defines
lrthmos=6400;' Amount to overshoot home before creeping back (TODO:refine guess)
lrtinpt=9;'  Digital in corresponding to the LoRes origin sensor
lrtinhx=$9;'  Digital in corresponding to the LoRes origin sensor in hex
lrtathm=1 ;'  value of origin sensor (via @IN) when at home
lrhomng=false;' Is the axis trying to home at present
lrswapp=-423000;' step position for lr grating swap

'Filter related defines
nfilt=8 ;' Number of filter slots
^a=nfilt+1;'Can't have expression within subscripts
'FES Elevator nominal filter position in steps
'Elevator travels .1" per rev (3200 steps) 
felstpsp=16*200*5;'steps  worth of space between filters
DM feselfp[^a]
feselfp[0]=1500
feselfp[1]=feselfp[0]+felstpsp
feselfp[2]=feselfp[1]+felstpsp
feselfp[3]=feselfp[2]+felstpsp
feselfp[4]=feselfp[3]+felstpsp
feselfp[5]=feselfp[4]+felstpsp
feselfp[6]=feselfp[5]+felstpsp
feselfp[7]=feselfp[6]+felstpsp
feselfp[8]=feselfp[7]+16*200*28.5
'FES Elevator nominal filter position in encoder counts
felencsp=317;'.5" filter spacing, 317 counts measured ?? nominal
DM felencp[^a]

;'Blue side 8/28/12
felencp[0]=79;'4.2803
felencp[1]=378;'felencp[0]+felencsp
felencp[2]=670;'felencp[1]+felencsp
felencp[3]=961.2;'felencp[2]+felencsp
felencp[4]=1256;'felencp[3]+felencsp
felencp[5]=1529;'felencp[4]+felencsp
felencp[6]=1812;'felencp[5]+felencsp
felencp[7]=2096;'felencp[6]+felencsp
felencp[8]=3848;'felencp[7]+1732;'Load position is an additional 2.85" further

;'Red side 8/28/12
felencp[0]=116.7;'4.2803
felencp[1]=413;'felencp[0]+felencsp
felencp[2]=705;'felencp[1]+felencsp
felencp[3]=992;'felencp[2]+felencsp
felencp[4]=1276;'felencp[3]+felencsp
felencp[5]=1559;'felencp[4]+felencsp
felencp[6]=1842.7;'felencp[5]+felencsp
felencp[7]=2128;'felencp[6]+felencsp
felencp[8]=3837;'felencp[7]+1732;'Load position is an additional 2.85" further

'Allowable range (+/-) in encoder counts around nominal filter position
feselrg=2 ;'2 is about 0.003"
allsafep=2746;'Encoder pos above which it is always safe to move the inserter

'FESIN related defines
fesinsp=9000 ;'The inserted position in steps of the FESIN arm
fesremp=1;'The removed position in steps of the FESIN arm, must be >0

'FLS related defines
flsbkof=25;'The steps to backoff after inserting


EN


'***************************************************************************
' Galil hardware config
'  Do not use any parameters in here, nothing is defined when this is called
'***************************************************************************
#M2FSCFG
ST;MC;MO*
'Set motor type, must be -2 or -2.5 per manual
MT -2.5,-2.5,-2.5,-2,-2,-2,-2.5,-2.5
KS*=1;'       Set step smoothing to Galil-recommended value, see AN#2446
AG 3,1,3,1,3,0,0,0;'              Set motor gain values
AQ1,4;AQ3,4;AQ5,4;AQ7,4;AQ8,4;'  GES,FOC,FESEL,HRTLT,HRAZ analog inputs: 0-10V
AF 1,,1,,1;'		Configure GES, FES, & FOC for analog feedback
YA 16,16,16,16,16,16,16,16;'Set stepping mode resolutions
YB 200,200,200,200,200,400,400,400;'Set stepper motor steps/revolution
LDE=3;'No limits on filter elevator
'Encoder resolution counts/rev (APPROXIMATE VALUES!)
'GES Nominally 44.7. GER R measured to be about 42.3
'FESEL measured to be 607.6 counts per inch on B side
YC 42,,26,,61 
'No built-in position error detection for steppers 	
ER*=-1			
'Configure: Limits active high, Home high -> go backward (retract)
'  to go home (needed by M228), Latch (Don't care), 
'  DI 4-7,12-15 axis specific aborts, Abort doesn't kill program
CN 1,-1,,1,1
CI 0
EN


'***************************************************************************
' Starutp Routine
'***************************************************************************
#AUTO
HX1;HX2;ST;MC;MO*
m2fsver=.1;bootup1=1
JS#M2FSCFG
JS#INIT

'Set acceleration defaults
AC axaccel[0],axaccel[1],axaccel[2],axaccel[3]
AC ,,,,axaccel[4],axaccel[5],axaccel[6],axaccel[7]

'Set deceleration defaults
DC axdecel[0],axdecel[1],axdecel[2],axdecel[3]
DC ,,,,axdecel[4],axdecel[5],axdecel[6],axdecel[7]

'Set limit switch triggered deceleration
SD axdecel[0],axdecel[1],axdecel[2],axdecel[3]
SD ,,,,axdecel[4],axdecel[5],axdecel[6],axdecel[7]

'Set homing velocity defaults
HV axhmspd[0],axhmspd[1],axhmspd[2],axhmspd[3]
HV ,,,,axhmspd[4],axhmspd[5],axhmspd[6],axhmspd[7]

'Set speed defaults
SP axspd[0],axspd[1],axspd[2],axspd[3]
SP ,,,,axspd[4],axspd[5],axspd[6],axspd[7]

'Query the Filter elevator position to initialize nearfilt
JS#QUFELP
'Start the analog filter
XQ #ANAMAF,1
'Start the HIRes lock monitor
XQ #LOCKMON,2
'Idle forever
#IDLE;WT 10000;JP#IDLE
EN


'***************************************************************************
' Shutdown Routine
'***************************************************************************
#SHTDWN
ST*;HX3;HX4;HX5;HX6;MC;MO*
a[3]=9;XQ#PICKFIL,3
a[4]=0;XQ#SETLRTL,4
JP#IDLE
EN


'***************************************************************************
' Motion Complete Timeout Routine
'TODO test with ultrishort timeout & long move, see if ST is needed b4 MO
'ST resets the stopcode
'***************************************************************************
#MCTIME
MG "MCTIME CALLED"
SCABCDEFGH
IF(_SCA=99);MOA;axiserr[0]=ETIME;STA;ENDIF
IF(_SCB=99);MOB;axiserr[1]=ETIME;STB;ENDIF
IF(_SCC=99);MOC;axiserr[2]=ETIME;STC;ENDIF
IF(_SCD=99);MOD;axiserr[3]=ETIME;STD;ENDIF
IF(_SCE=99);MOE;axiserr[4]=ETIME;STE;ENDIF
IF(_SCF=99);MOF;axiserr[5]=ETIME;STG;ENDIF
IF(_SCG=99);MOG;axiserr[6]=ETIME;STG;ENDIF
IF(_SCH=99);MOH;axiserr[7]=ETIME;STH;ENDIF
SCABCDEFGH
EN 1

'***************************************************************************
' CALibrate LoRes Tilt
' Calibrate the LoRes tilt
' Does not turn axis off if sucessful
' Returns ENONE iff sucessful
' Errors: ELRTSEN - home sensor failed
' assumes LoRes Axis is "F"
'***************************************************************************
#CALLRT
'Stack and XQ fancy footwork
JS#ZS;IF (_JS<1);JS#CALLRT;^h=_JS;ed4=_ED4;ret[ed4]=_JS;ELSE
'Axis F, Hope Success
^a=LRTLTAX;^h=ENONE
'Find home sensor if not there already
IF (@IN[lrtinpt]<>lrtathm)
II ,,lrtinhx,lrtinhx;'Trip on @IN[lrtinpt] goes to 1
lrhomng=true
'Do a relative move -1.1 revolutions
~a=^a;^b=-1.10*(axmaxp[^a]-axminp[^a])
~a=^a; AC~a=axaccel[^a]; DC~a=axdecel[^a]; SP~a=axspd[^a];PR~a=^b;SH~a; BG~a
' wait till stopped (input interrupt stopped us) or get to position
#CALLRT1;WT 500;JP#CALLRT1, (_SCF=0);~a=^a;MC~a
'If not stopped by ST in interrupt routine turn off and fail.
IF (_SCF<>4);~a=^a;MO~a;^h=EHMERR
ENDIF;ENDIF
'If all is well
IF (^h=ENONE)
'Continue on to move off the home sensor
^b=-lrthmos
~a=^a;AC~a=axaccel[^a];DC~a=axdecel[^a];SP~a=axspd[^a];PR~a=^b;SH~a;BG~a;MC~a
'Move to home sensor
lrhomng=true
^b=(1.1*lrthmos)+bcklsh[^a] 
~a=^a; DC~a=axdecel[^a]; SP~a=axhmspd[^a]; PR~a=^b;SH~a; BG~a
' wait till stopped (input interrupt stopped us) or get to position
#CALLRT2;WT 500;JP#CALLRT2, (_SCF=0);~a=^a;MC~a
'If not stopped by ST in interrupt routine turn off and fail
' else Define the new position as home
IF (_SCF<>4);~a=^a;MO~a;^h=EHMERR
ELSE;~a=^a;DP~a=0;axiscal[^a]=true;ldelta[^a]=^b
ENDIF
ENDIF
' Turn off input interrupt and store status
II 0,,,;axiserr[^a]=^h
ENDIF
EN ,,^h


'***************************************************************************
' INput change INTerrupt
' If LoRes Tilt is homing and the input is triggered then halt the motion and
'  SHF (this should mean that a MC trippoint on the axis is cleared.)
'  TODO call galil re this
'***************************************************************************
#ININT
IF ((lrhomng=true)&(@IN[lrtinpt]=lrtathm))
REM DCF=axdecel[5] This command is reported as not valid while running yet I can 
REM  execute it over serial w/o any problem TODO: CALL GALIL 
REM STF;SHF;lrhomng=false
STF;lrhomng=false;ENDIF
RI


'***************************************************************************
' Get LoRes TiLt position
'***************************************************************************
#GETLRTL
^a=LRTLTAX
'Error status
IF(axiserr[^a]<>ENONE);JS#ERRMSG(^a,axiserr[^a])
'Move in progress
ELSE; ~a=^a;IF(_TS~a & $80);MG "GETLRTL: MOVING"
'Not calibrated
ELSE; IF(axiscal[^a]<>true);MG "GETLRTL: UNCALIBRATED"
'report position
ELSE; ~a=^a; MG "GETLRTL:",_TD~a
ENDIF;ENDIF;ENDIF
EN


'***************************************************************************
' Set LoRes TiLt(angle)
' Set the lo res tilt angle
'***************************************************************************
#SETLRTL
'Stack and XQ fancy footwork
JS#ZS;IF (_JS<1);ed4=_ED4;JS#SETLRTL(a[ed4]);^h=_JS;ed4=_ED4;ret[ed4]=_JS;ELSE
^b=^a
^a=LRTLTAX
'Calibrate if not
IF (axiscal[^a]<>true);JS#CALLRT;^h=_JS;ENDIF
'If we are good to go, MOVE!
IF(^h=ENONE);JS#FANCYMV(^a,^b);~a=^a;MC~a;~a=^a;MO~a;ENDIF
'Store status
axiserr[^a]=^h
ENDIF
EN,,^h


'***************************************************************************
' Get HiRes TiLt position
'***************************************************************************
#GETHRTL
^a=HRTLTAX;
'Error status
IF(axiserr[^a]<>ENONE);JS#ERRMSG(^a,axiserr[^a])
'Move in progress
ELSE; ~a=^a;IF(_TS~a & $80);MG "GETHRTL: MOVING"
'Not calibrated
ELSE; IF(axiscal[^a]<>true);MG "GETHRTL: UNCALIBRATED"
'report position
ELSE; ~a=^a; MG "GETHRTL:",_TD~a
ENDIF;ENDIF;ENDIF
EN


'***************************************************************************
' Set HiRes TiLt(steps)
' Set the hi res tilt angle
'***************************************************************************
#SETHRTL
'Stack and XQ fancy footwork
JS#ZS;IF(_JS<1);ed4=_ED4;JS#SETHRTL(a[ed4]);^h=_JS;ed4=_ED4;ret[ed4]=_JS;ELSE
^b=^a
^a=HRTLTAX
^h=0;'Hope success
'Make sure the axis isn't locked
IF(HRTLTLK=true);^h=ELCKERR;ENDIF
'If we are good to go, make sure commanded position is sane
IF(^h=ENONE);JS#SANEPOS(^a,^b);IF(_JS<>true);^h=ECRAZY;ENDIF
'If we are good to go, but not calibrated, calibrate
IF ((^h=ENONE)&(axiscal[^a]<>true));JS#CALHMAX(^a);^h=_JS;ENDIF
'If we are good to go, MOVE!
IF(^h=ENONE);JS#FANCYMV(^a,^b);~a=^a;MC~a;~a=^a;MO~a;ENDIF
ENDIF
'Store status
axiserr[^a]=^h
ENDIF
EN,,^h


'***************************************************************************
' Calibrate HiRes Azimuth position
'***************************************************************************
#CALHRAZ;JS#CALHMAX(HRAZAX);ed4=_ED4;ret[ed4]=_JS;EN


'***************************************************************************
' Get HiRes AZimuth position
'***************************************************************************
#GETHRAZ
^a=HRAZAX;
'Error status
IF(axiserr[^a]<>ENONE);JS#ERRMSG(^a,axiserr[^a])
'Move in progress
ELSE; ~a=^a;IF(_TS~a & $80);MG "GETHRAZ: MOVING"
'Not calibrated
ELSE; IF(axiscal[^a]<>true);MG "GETHRAZ: UNCALIBRATED"
'report position
ELSE; ~a=^a; MG "GETHRAZ:",_TD~a
ENDIF;ENDIF;ENDIF
EN


'***************************************************************************
' Set HiRes AZimuth(steps)
' Set the hi res azimuth position
'***************************************************************************
#SETHRAZ
'Stack and XQ fancy footwork
JS#ZS;IF(_JS<1);ed4=_ED4;JS#SETHRAZ(a[ed4]);^h=_JS;ed4=_ED4;ret[ed4]=_JS;ELSE
^b=^a
^a=HRAZAX
^h=0;'Hope success
'Make sure the axis isn't locked
IF(HRAZLK=true);^h=ELCKERR;ENDIF
'If we are good to go, make sure commanded position is sane
IF(^h=0);JS#SANEPOS(^a,^b);IF(_JS<>true);^h=ECRAZY;ENDIF
'If we are good to go, but not calibrated, calibrate
IF ((^h=0)&(axiscal[^a]<>true));JS#CALHMAX(^a);^h=_JS;ENDIF
'If we are good to go, MOVE!
IF(^h=0);JS#FANCYMV(^a,^b);~a=^a;MC~a;~a=^a;MO~a;ENDIF
ENDIF
'Store status
axiserr[^a]=^h
ENDIF
EN,,^h


'***************************************************************************
' Calibrate the GES Stage
' return value is in ret
'***************************************************************************
#CALGES;JS#CALENAX(GESAX);ed4=_ED4;ret[ed4]=_JS;EN


'***************************************************************************
' QUery GES Position
' returns hires, lores, unknown, intermd
' TODO sort out behavior for case where motor and pot disagree
'***************************************************************************
#QUGESP
^a=GESAX
'Move in progress
~a=^a;IF (_TS~a & $80);^h=moving
ELSE;IF(axiscal[^a]<>true);^h=unknown
ELSE
'Wait for filtered analog position to be clean
JS#WAITAMF(^a)
REM ^g step position
REM ^b encoder position
REM ^c step position is equal to geslrp
REM ^d encoder position is within tolerance of lores position
REM ^e step position is equal to geshrp
REM ^f encoder position is within tolerance of hires position
~a=^a;^g=_TD~a;^b=gesanap;^c=(^g=geslrp);^e=(^g=geshrp)
^d=( ((^b>(geslrep-gesenct) & (^b<(geslrep+gesenct)) )
^f=( ((^b>(geshrep-gesenct) & (^b<(geshrep+gesenct)) )
IF (^c & ^d);^h=lores
ELSE;IF (^e & ^f);^h=hires
ELSE;IF (((^d=0) & ^c) | (^e & (^f=0)));^h=EGESPMM;axiserr[^a]=^h
ELSE;^h=intermd;ENDIF
ENDIF;ENDIF;ENDIF;ENDIF
EN,,^h


'***************************************************************************
' Get GES
' Return the GES position
'***************************************************************************
#GETGES
^a=GESAX
'Determine status
~a=^a;IF (_TS~a & $80);^h=moving
ELSE;IF(anapcln[^a]<>-1);^h=moving;'settle
ELSE;IF(axiscal[^a]<>true);^h=unknown
ELSE
REM ^g step position
REM ^b encoder position
REM ^c step position is equal to geslrp
REM ^d encoder position is within tolerance of lores position
REM ^e step position is equal to geshrp
REM ^f encoder position is within tolerance of hires position
~a=^a;^g=_TD~a;^b=gesanap;^c=(^g=geslrp);^e=(^g=geshrp)
^d=( ((^b>(geslrep-gesenct) & (^b<(geslrep+gesenct)) )
^f=( ((^b>(geshrep-gesenct) & (^b<(geshrep+gesenct)) )
IF (^c & ^d);^h=lores
ELSE;IF (^e & ^f);^h=hires
ELSE;IF (((^d=0) & ^c) | (^e & (^f=0)));axiserr[^a]=EGESPMM
ELSE;^h=intermd
ENDIF;ENDIF;ENDIF
ENDIF;ENDIF;ENDIF
'Report status
IF(axiserr[^a]<>ENONE);JS#ERRMSG(^a,axiserr[^a])
ELSE
IF(^h=unknown);MG "GETGES: UNCALIBRATED";ENDIF
IF(^h=moving);~a=^a;MG "GETGES: MOVING",_TP~a,_TD~a;ENDIF
IF(^h=settle);~a=^a;MG "GETGES: SETTLING",gesanap,_TD~a;ENDIF
IF(^h=lores);~a=^a;MG "GETGES: LORES",gesanap,_TD~a;ENDIF
IF(^h=hires);~a=^a;MG "GETGES: HIRES",gesanap,_TD~a;ENDIF
IF(^h=lrswap);~a=^a;MG "GETGES: SWAP",gesanap,_TD~a;ENDIF
IF(^h=intermd);~a=^a;MG "GETGES: INTERMEDIATE",gesanap,_TD~a;ENDIF
ENDIF
EN


'***************************************************************************
' QUery GES Position (simple, ignore analog encoder)
' returns hires, lores, unknown, intermd
' TODO sort out behavior for case where motor and pot disagree
'***************************************************************************
#QUGESP2
^a=GESAX;~a=^a;^g=_TD~a
~a=^a;IF (_TS~a & $80);^h=moving
ELSE;IF(axiscal[^a]<>true);^h=unknown
ELSE;IF (^g=geslrp);^h=lores
ELSE;IF (^g=geshrp);^h=hires
ELSE;IF (^g=gesgsp);^h=lrswap
ELSE;^h=intermd
ENDIF;ENDIF;ENDIF;ENDIF;ENDIF
EN,,^h


'***************************************************************************
' Get GES (simple, ignore analog encoder)
' Return the GES position
'***************************************************************************
#GETGES2
^a=GESAX
'Determine status
~a=^a;IF (_TS~a & $80);^h=moving
ELSE;IF(anapcln[^a]<>-1);^h=moving;'settle
ELSE;IF(axiscal[^a]<>true);^h=unknown
ELSE
REM ^g step position
~a=^a;^g=_TD~a
IF (^g=geslrp);^h=lores
ELSE;IF (^g=geshrp);^h=hires
ELSE;IF (^g=gesgsp);^h=lrswap
ELSE;^h=intermd
ENDIF;ENDIF;ENDIF;ENDIF;ENDIF;ENDIF
'Report status
IF(axiserr[^a]<>ENONE);JS#ERRMSG(^a,axiserr[^a])
ELSE
IF(^h=unknown);MG "GETGES: UNCALIBRATED";ENDIF
IF(^h=moving);~a=^a;MG "GETGES: MOVING",_TP~a,_TD~a;ENDIF
IF(^h=lores);~a=^a;MG "GETGES: LORES",gesanap,_TD~a;ENDIF
IF(^h=hires);~a=^a;MG "GETGES: HIRES",gesanap,_TD~a;ENDIF
IF(^h=lrswap);~a=^a;MG "GETGES: LRSWAP",gesanap,_TD~a;ENDIF
IF(^h=intermd);~a=^a;MG "GETGES: INTERMEDIATE",gesanap,_TD~a;ENDIF
ENDIF
EN




'***************************************************************************
' LoRes grating swap
'***************************************************************************
#LRSWAP
'Stack and XQ fancy footwork
JS#ZS;IF (_JS<1);JS#LRSWAP;^h=_JS;ed4=_ED4;ret[ed4]=_JS;ELSE
^h=ENONE;'      Hope for success
^a=LRTLTAX
'Calibrate if not
IF (axiscal[^a]<>true);JS#CALLRT;^h=_JS;ENDIF
'Calibrate if needed
^a=GESAX
IF(axiscal[^a]<>true);JS#CALENAX(^a);^h=(^h | _JS);ENDIF
'If we are good to go, MOVE!
IF(^h=ENONE)
JS#FANCYMV(LRTLTAX,lrswapp);JS#FANCYMV(GESAX,gesgsp)
^a=LRTLTAX;~a=^a;MC~a;~a=^a;MO~a
^a=GESAX;~a=^a;MC~a;~a=^a;MO~a
'Verify we are in an acceptable position
JS#QUGESP2;IF (_JS<>lrswap);^h=EFAIL;ENDIF
ENDIF
axiserr[^a]=^h;'Store status
ENDIF
EN,,^h



'***************************************************************************
' HIgh RESolution mode
'***************************************************************************
#HIRES
'Stack and XQ fancy footwork
JS#ZS;IF (_JS<1);JS#HIRES;^h=_JS;ed4=_ED4;ret[ed4]=_JS;ELSE
^a=GESAX;^h=ENONE;'      Hope for success
'Calibrate if needed
IF(axiscal[^a]<>true);JS#CALENAX(^a);^h=_JS;ENDIF
'If all is well start moving to position
IF(^h=0);JS#FANCYMV(^a,geshrp);~a=^a;MC~a;~a=^a;MO~a
'Verify we are in an acceptable position
JS#QUGESP2;IF (_JS<>hires);^h=EFAIL;ENDIF
ENDIF
axiserr[^a]=^h;'Store status
ENDIF
EN,,^h


'***************************************************************************
' LOw RESolution mode
'***************************************************************************
#LORES
'Stack and XQ fancy footwork
JS#ZS;IF (_JS<1);JS#LORES;^h=_JS;ed4=_ED4;ret[ed4]=_JS;ELSE
^a=GESAX;^h=ENONE;'      Hope for success
'Calibrate if needed
IF(axiscal[^a]<>true);JS#CALENAX(^a);^h=_JS;ENDIF
'If all is well start moving to position
IF(^h=ENONE);JS#FANCYMV(^a,geslrp);~a=^a;MC~a;~a=^a;MO~a
'Verify we are in an acceptable position
JS#QUGESP2;IF (_JS<>lores);^h=EFAIL;ENDIF
ENDIF
axiserr[^a]=^h;'Store status
ENDIF
EN,,^h


'***************************************************************************
' Get Focus Position
' Does not wait for analog value to stabilize
'***************************************************************************
#GETFOC
^a=FOCAX
'Error status
IF(axiserr[^a]<>ENONE);JS#ERRMSG(^a,axiserr[^a])
'Move in progress
ELSE; ~a=^a;IF((_TS~a & $80)|(anapcln[^a]<>-1))
~a=^a;MG "GETFOC: MOVING",focanap,_TD~a
'Report position
ELSE; ~a=^a; MG "GETFOC:",focanap,_TD~a
ENDIF;ENDIF
EN


'***************************************************************************
' Set FOC Position(Encoder position)
'***************************************************************************
#SETFOC
'Stack and XQ fancy footwork
JS#ZS;IF(_JS<1);ed4=_ED4;JS#SETFOC(a[ed4]);^h=_JS;ed4=_ED4;ret[ed4]=_JS;ELSE
^b=^a
^a=FOCAX
MG "Requested p:",^b 
'Wait for filtered analog position to be clean
JS#WAITAMF(^a)
^c=^b-focanap
'MG "Counts to convert:",^c
JS#ENC2STP(^a,^c);~a=^a;^c=_TD~a+_JS
'MG "Moving to:",^b
~a=^a;JS#FANCYMV(^a,^c);~a=^a;MC~a;~a=^a;MO~a
'Rince lather repeat x1 a few times, PID loop would be "proper"
JS#WAITAMF(^a)
^c=^b-focanap
IF(@ABS[^c]>focentol)
JS#ENC2STP(^a,^c);~a=^a;^c=_TD~a+_JS
~a=^a;JS#FANCYMV(^a,^c);~a=^a;MC~a;~a=^a;MO~a
'Rince lather repeat x2
JS#WAITAMF(^a)
^c=^b-focanap
IF(@ABS[^c]>focentol)
JS#ENC2STP(^a,^c);~a=^a;^c=_TD~a+_JS
~a=^a;JS#FANCYMV(^a,^c);~a=^a;MC~a;~a=^a;MO~a
ENDIF;ENDIF
ENDIF
EN


'***************************************************************************
' GET FES Iserter status
' responds "IN" "OUT" "UNKNOWN" "INTERMEDIATE", "MOVING"
'***************************************************************************
#GETFESI
^a=FESINAX
'Error status
IF(axiserr[^a]<>ENONE);JS#ERRMSG(^a,axiserr[^a])
ELSE
'Report position
^a=unknown
IF ((_LFD=0)&(_LRD=1));^a=in;ENDIF
IF ((_LFD=1)&(_LRD=0));^a=out;ENDIF
IF (_TSD & $80); ^a=moving;ENDIF
IF (^a=out);MG "GETFESI: OUT";ENDIF
IF (^a=moving);MG "GETFESI: MOVING";ENDIF
IF (^a=in);MG "GETFESI: IN";ENDIF
IF (^a=intermd);MG "GETFESI: INTERMEDIATE";ENDIF
IF (^a=unknown);MG "GETFESI: UNKNOWN";ENDIF
ENDIF
EN


'***************************************************************************
' INsert FES INserter arm
'***************************************************************************
#INFESIN
'Stack and XQ fancy footwork
JS#ZS;IF (_JS<1);JS#INFESIN;^h=_JS;ed4=_ED4;ret[ed4]=_JS;ELSE
^h=ENONE;^a=FESINAX;'          Hope for success
IF(_LFD=1);' If not inserted
'Make sure the FESEL is in a safe position to remove filter
JS#FESELSF;^h=_JS
IF(^h=ENONE);'insert the FESIN if all is well
MG "FESELSF reports safe, inserting"
JS#MOV2LIM(^a, axaccel[^a], axdecel[^a], axlmspd[^a]);^h=_JS
REM Check error cases
IF (^h=ENONE)
IF ((_LFD=1)|(_LRD=0));^h=ELIMSWF;MG "Insert failed";ENDIF
ELSE
MG "MOVE2LIM failed."
ENDIF
~a=^a;MC~a;~a=^a;MO~a
ELSE
MG"FESELSF Reports unsafe"
ENDIF
ELSE
IF(_LRD=0);^h=ELIMSWF;MG "Both Limits tripped. fail"
ELSE; MG "Already In";ENDIF
ENDIF
axiserr[^a]=^h
ENDIF
EN,,^h


'***************************************************************************
' ReMove FES INserter arm
'***************************************************************************
#RMFESIN
'Stack and XQ fancy footwork
JS#ZS;IF (_JS<1);JS#RMFESIN;^h=_JS;ed4=_ED4;ret[ed4]=_JS;ELSE
^h=ENONE;^a=FESINAX;'          Hope for success
IF(_LRD=1);' If not retracted
'Make sure the FESEL is in a safe position to remove filter
JS#FESELSF;^h=_JS
IF(^h=ENONE);'Remove the FESIN if all is well
MG "FESELSF reports safe, removing inserter"
JS#MOV2LIM(^a, axaccel[^a], axdecel[^a], -axlmspd[^a]);^h=_JS
IF ((_LFD=1)&(_LRD=0)&(^h=ENONE))
'Move to the removed idle position
MG"Moving to keyway spot"
~a=^a;DP~a=0;JS#FANCYMV(^a,fesremp);~a=^a;MC~a
~a=^a;IF(_SC~a<>1);^h=EFAIL;MG "FANCYMV failed. SC=",_SC~a;ENDIF
~a=^a;MO~a
ELSE
^h=ELIMSWF;~a=^a;MC~a;~a=^a;MO~a
MG "MOVE2LIM failed."
ENDIF
ELSE
MG"FESELSF Reports unsafe"
ENDIF
ELSE
IF(_LFD=0);^h=ELIMSWF;MG "Both Limits tripped. fail"
ELSE; MG "Already out";ENDIF
ENDIF
axiserr[^a]=^h
ENDIF
EN,,^h


'***************************************************************************
' FES ELevator SaFe
' Returns 0 if the elevator is in a safe position for the 
'  FESIN arm to move
' Cases:
'   caddy is above inserter or within tolerance of a filter position: return 0
'   caddy is in front of inserter, but not within tolerance of filter position
'    if the inserter position is == fesremp
'      nudge to the nearest filter
'      if within tolerance return true
'    fail
' If the elevator isn't is a safe position it attempts to move it to a safe
' position
'***************************************************************************
#FESELSF
'Stack and XQ fancy footwork
JS#ZS;IF (_JS<1);ed4=_ED4;JS#FESELSF;^h=_JS;ed4=_ED4;ret[ed4]=_JS;ELSE
^a=FESELAX
'Hope for success
^h=ENONE
JS#WAITAMF(^a)
'Case 1: caddy is above inserter return 0
IF(felanap>allsafep);^h=ENONE
MG "Caddy above inserter. Safe."
ELSE
'Check if position is within tolerance of a filter position
JS#QUFELP;IF( (_JS>=filterp1) & (_JS<=filterp8) );^h=ENONE
MG "Caddy at a filter. Safe."
ELSE
'We are in a position that needs fine tuning before it is safe to 
' move the FESIN arm, but it is only safe to tweak the position if the
' inserter position is known
JS#QUINPOS(FESINAX,fesinsp,fesremp)
IF (_JS<>out); ^h=EFLTUNSF
MG "Caddy needs to move. Inserter not out. Unsafe."
ELSE
'Try to nudge elevator toward nearest valid position
'Compute number of steps between current encoder position and nominal 
' encoder position filter
JS#WAITAMF(^a)
^b=nearfilt-filterp1;'NB nearfilt is defermined by QUFELP
^b=felencp[^b]-felanap;'encoder distance to nearest filter pos
JS#ENC2STP(FESELAX,^b)
'Compute new desired position
~a=^a;^b=_TD~a+_JS
JS#FANCYMV(^a,^b);~a=^a;MC~a;~a=^a;MO~a
'Check the position again
JS#QUFELP
'If we still aren't in a safe spot fail
IF( ((_JS>=filterp1) & (_JS<=filterp8)) | (felanap>allsafep) );^h=ENONE
MG "Caddy position adjusted and arm is clear to move. Safe."
ELSE;^h= EFLTUNSF;axiserr[^a]=EFLTUNSF
MG "Could not manage to get caddy in safe position. Unsafe."
ENDIF;ENDIF;ENDIF;ENDIF
axiserr[^a]=^h
ENDIF
EN,,^h


'***************************************************************************
' QUery Filter ELevator Position
' returns moving, filterp1,...,filterp8, filterld, intermd
' Does not consider inserter arm status
'***************************************************************************
#QUFELP
^a=FESELAX
~a=^a;IF(_SC~a=0);^h=moving
ELSE
'Wait for filtered analog position to be clean
JS#WAITAMF(^a)
'Determine which filter is nearest current position 
'Compute abs(feselfp[i]-position)
^f=felanap
^d=@ABS[(felencp[0]-^f)];^e=0;^b=1
'find minumum 
'^e=i of nearest filter
'^d=encoder dist to filter
#QUFELP1
^c=@ABS[felencp[^b]-^f]
IF (^c<^d);^d=^c;^e=^b;ENDIF;^b=^b+1
JP#QUFELP1,(^b<=nfilt)
'Store the nearest filter
nearfilt=^e+filterp1
'If minimum is < feselrg then we are in the position
IF(^d<feselrg)
'Convert ^e to the return value
^h=^e+filterp1
ELSE
'Not in position of a filter
^h=intermd
ENDIF
ENDIF
MG "QUFELP: ",^h
EN,,^h


'***************************************************************************
' GET FILTer
'   Report the current filter
'  Filter 1-8 In, Out?????TODO, None, Load, Moving, Intermediate
'***************************************************************************
#GETFILT
'Stack and XQ fancy footwork
JS#ZS;IF (_JS<1);JS#GETFILT;ed4=_ED4;ret[ed4]=0;ELSE
'Error status
IF(axiserr[FESELAX]<>ENONE);JS#ERRMSG(FESELAX,axiserr[FESELAX])
ELSE
^a=unknown
IF ((_LFD=0)&(_LRD=1));^a=in;ENDIF
IF ((_LFD=1)&(_LRD=0));^a=out;ENDIF
IF (_TSD & $80); ^a=moving;ENDIF
JS#QUFELP;^b=_JS
IF((^a=moving)|(^b=moving));MG "GETFILT: MOVING"
ELSE;IF(^b=filterld);MG "GETFILT: LOAD"
ELSE;IF(^a=unknown);MG "GETFILT: UNKNOWN"
ELSE;IF(^a=out);MG "GETFILT: NONE"
ELSE;IF((^a=intermd)|(^b=intermd);MG "GETFILT: Intermediate"
ELSE;'One will match
IF(^b=filterp1);MG "GETFILT: 1";ENDIF
IF(^b=filterp2);MG "GETFILT: 2";ENDIF
IF(^b=filterp3);MG "GETFILT: 3";ENDIF
IF(^b=filterp4);MG "GETFILT: 4";ENDIF
IF(^b=filterp5);MG "GETFILT: 5";ENDIF
IF(^b=filterp6);MG "GETFILT: 6";ENDIF
IF(^b=filterp7);MG "GETFILT: 7";ENDIF
IF(^b=filterp8);MG "GETFILT: 8";ENDIF
ENDIF;ENDIF;ENDIF;ENDIF;ENDIF;ENDIF
ENDIF
EN


'***************************************************************************
' Pick FILter(filternum)
' 1-10,
' 1-8= Filters 1-8
' 9  = load position
' 10 = no filter
' Forces filternum to be integer
'***************************************************************************
#PICKFIL
'Stack and XQ fancy footwork
JS#ZS;IF (_JS<1);ed4=_ED4;JS#PICKFIL(a[ed4]);^h=_JS;ed4=_ED4;ret[ed4]=_JS;ELSE
'Hope for success, force filternum to an integer
^h=ENONE;^a=@INT[^a]-1
'Check for invalid filter id
IF ((^a<0)|(^a>9));^h=EBADFP
ELSE;'ID valid, get current state of elevator (^b) and inserter (^c)
JS#QUFELP;^b=_JS-filterp1
^c=unknown
IF ((_LFD=0)&(_LRD=1));^c=in;ENDIF
IF ((_LFD=1)&(_LRD=0));^c=out;ENDIF
IF (_TSD & $80); ^c=moving;ENDIF
IF (^c=in); MG "Inserter is in.";ENDIF
IF (^c=moving); MG "Inserter is moving.";ENDIF
IF (^c=out); MG "Inserter is out.";ENDIF
IF (^c=unknown); MG "Inserter is unknown.";ENDIF
'If the desired position = current position we are done
IF( ((^a=9)&(^c=out)) | ( ((^c=in)|(^a=8)) & (^b=^a) ) );^h=ENONE
ELSE;'We are not in position
'Stow the FESIN arm, note REFESIN ensures safe to move
JS#RMFESIN;^h=_JS
'If arm retracted, desired filter != none
IF ((^h=ENONE)&(_LRD=0)&(_LFD=1)&(^a<>9))
'Move to the desired filter

JS#WAITAMF(FESELAX)
^d=(felencp[^a]-felanap);JS#ENC2STP(FESELAX,^d);^d=_TDE+_JS
MG "Arm out. Moving to filter",^a," at",felencp[^a]," move",_JS," steps"
JS#FANCYMV(FESELAX,^d);~a=FESELAX;MC~a;~a=FESELAX;MO~a

JS#WAITAMF(FESELAX)
^d=(felencp[^a]-felanap);JS#ENC2STP(FESELAX,^d);^d=_TDE+_JS
MG "Arm out. Moving to filter",^a," at",felencp[^a]," move",_JS," steps"
JS#FANCYMV(FESELAX,^d);~a=FESELAX;MC~a;~a=FESELAX;MO~a

JS#WAITAMF(FESELAX)
^d=(felencp[^a]-felanap);JS#ENC2STP(FESELAX,^d);^d=_TDE+_JS
MG "Arm out. Moving to filter",^a," at",felencp[^a]," move",_JS," steps"
JS#FANCYMV(FESELAX,^d);~a=FESELAX;MC~a;~a=FESELAX;MO~a

MG "Done moving, getting position"
'Get current state of elevator
JS#QUFELP;^b=_JS
MG "QEFELP reports",^b
IF( ((^b-filterp1)=^a) & (^b<>intermd) );'If we are where we should be...
'Insert the filter if needed
IF(^b<>filterld);MG "Inserting";JS#INFESIN;^h=_JS
MG "#INFESIN returned",^h
ELSE;^h=ENONE;ENDIF
ELSE;^h=EFLTUNSF
MG "PICKFIL: EFLTUNSF"
ENDIF
ENDIF;ENDIF;ENDIF
axiserr[FESELAX]=^h
ENDIF
EN,,^h


'***************************************************************************
' GET FLS Inserter status
' responds "IN" "OUT" "UNKNOWN" "INTERMEDIATE" "MOVING"
'***************************************************************************
#GETFLSI
'Stack and XQ fancy footwork
JS#ZS;IF (_JS<1);JS#GETFLSI;ELSE
^a=FLSINAX
'Error status
IF(axiserr[^a]<>ENONE);JS#ERRMSG(^a,axiserr[^a])
ELSE
^h=unknown
IF ((_LFB=1)&(_LRB=0));^h=out;ENDIF
IF ((_LFB=0)&(_LRB=1));^h=in;ENDIF
IF (_TSB & $80); ^h=moving;ENDIF
IF (^h=out);MG "GETFLSI: OUT";ENDIF
IF (^h=moving);MG "GETFLSI: MOVING";ENDIF
IF (^h=in);MG "GETFLSI: IN";ENDIF
IF (^h=unknown);MG "GETFLSI: UNKNOWN";ENDIF
ENDIF;ENDIF
EN


'***************************************************************************
' INsert FLS INserter arm
'***************************************************************************
#INFLSIN
'Stack and XQ fancy footwork
JS#ZS;IF (_JS<1);JS#INFLSIN;^h=_JS;ed4=_ED4;ret[ed4]=_JS;ELSE
^h=ENONE;^a=FLSINAX
IF(_LFB=1);JS#MOV2LIM(^a, axaccel[^a], axdecel[^a], axlmspd[^a]);^h=_JS;ENDIF
IF(^h=ENONE);^b=(_TDB-25);JS#FANCYMV(^a,^b);ENDIF
~a=^a;MC~a;~a=^a;MO~a
IF ((_LFB=1) | (_LRB=0)); ^h=ELIMSWF;ENDIF
axiserr[^a]=^h
ENDIF
EN,,^h


'***************************************************************************
' ReMove FLS INserter arm
' NB it is always safe to remove
'***************************************************************************
#RMFLSIN
'Stack and XQ fancy footwork
JS#ZS;IF (_JS<1);JS#RMFLSIN;^h=_JS;ed4=_ED4;ret[ed4]=_JS;ELSE
^h=ENONE;^a=FLSINAX
IF(_LRB=1)
JS#MOV2LIM(^a, axaccel[^a], axdecel[^a], -axlmspd[^a]);^h=_JS
~a=^a;MC~a;~a=^a;MO~a
ENDIF
IF ((_LFB=0)|(_LRB=1));^h=ELIMSWF;ENDIF
axiserr[^a]=^h;'Store status
ENDIF
EN,,^h


'***************************************************************************
' QUery INserter POSition status (AXIS, inserted step pos, removed step pos)
' returns: out, in, intermediate, unknown (if uncalibrated), or moving
'***************************************************************************
#QUINPOS;'(axis,insertedpos,removedpos)
^h=unknown;'Default uncalibrated
~a=^a;IF(_TS~a & $80); ^h=moving
ELSE; IF (axiscal[^a]=true)
'Stopped, out position
~a=^a;IF ((_SC~a=1) & (_TD~a=^c));^h=out
'Stopped, in position
~a=^a;ELSE;IF ((_SC~a=1) & (_TD~a=^b));^h=in
'Stopped, somewhere else
ELSE;^h=intermd
ENDIF;ENDIF;ENDIF;ENDIF
MG "QUINPOS",^a, ^h
EN,,^h


'***************************************************************************
' CALibrate HoMe-switched, unencoded AXis(axis)
' Calibrate an axis that has a home switch but no encoder
' If home switch fails then sends EHMERR
' Does not turn axis off if sucessful, 
' For use on axes w/o pot & with a Home switch (HRTLT,HRAZ)
' Returns 0 iff sucessful
'***************************************************************************
#CALHMAX;'(axis)
'Stack and XQ fancy footwork
JS#ZS;IF (_JS<1);ed4=_ED4;JS#CALHMAX(a[ed4]);^h=_JS;ed4=_ED4;ret[ed4]=_JS;ELSE
IF ((^a<>HRTLTAX)&(^a<>HRAZAX));^h=EFAIL
ELSE
^h=ENONE
JS#MOV2LIM(^a, axaccel[^a], axdecel[^a], -axlmspd[^a]);^h=_JS
IF (^h=ENONE)
~a=^a;HV~a=axhmspd[^a];SP~a=axspd[^a];DC~a=axdecel[^a];SH~a;HM~a;BG~a
~a=^a;MC~a
'If we didn't stop because of homing then the home switch broke.
~a=^a;IF(_SC~a<>10);ST~a;MC~a;~a=^a;MO~a;^h=EHMERR
ELSE;'Define the new position as home
~a=^a;MC~a;~a=^a;DP~a=0;axiscal[^a]=true;^h=0;ldelta[^a]=-10*bcklsh[^a]
ENDIF;ENDIF;ENDIF
axiserr[^a]=^h
ENDIF
EN ,,^h


'***************************************************************************
' CALibrate ENcoded AXis(axis)
' Calibrate an axis that has an analog encoder
' Does not turn axis off if sucessful, 
' For use on axes w/o pot & with a Home switch (GES)
' Returns 0 iff sucessful
'***************************************************************************
#CALENAX
IF(^a<>GESAX);^h=EFAIL
ELSE
'Hope for success
^h=ENONE
'MG "#Wait"
'Wait for filtered analog position to be clean
JS#WAITAMF(^a);^b=analogp[^a]
'If pot reads close to the negative limit move positive by a little
IF(^b < encnlim[^a])
^b=1024;'5*(encnlim[^a]-^b)
JS#ENC2STP(^a,^b);~a=^a;AC~a=axaccel[^a]; DC~a=axdecel[^a];SP~a=axspd[^a]
'MG "Pot reads close to the -limit move positive a little", ^b,_JS
~a=^a;PR~a=_JS;SH~a;BG~a;MC~a
ENDIF
'MG "Wait"
'Wait for clean analog position and Overestimate distance to -limit
JS#WAITAMF(^a);JS#ENC2STP(^a,analogp[^a]);^b=2*_JS
'MG "Overest dist to -lim and start a move to past limit",-^b
~a=^a;AC~a=axaccel[^a];DC~a=axdecel[^a];SP~a=axlmspd[^a];PR~a=-^b;SH~a;BG~a
'Wait until stopped
#CALENA1;WT500;~a=^a;JP#CALENA1, (_SC~a=0);~a=^a;MC~a
'If we weren't stopped by the -limit, fail
~a=^a;IF(_SC~a<>3);^h=ELIMSWF
'MG"Not stopped by -limit,fail."
ELSE
'If we somehow overshot limit move forward slowly until on limit
~a=^a;IF(_LR~a=1)
'Try to move back onto the limit
'MG "Wait"
JS#WAITAMF(^a);JS#ENC2STP(^a,analogp[^a]);^b=1.1*_JS
'MG "overshot limit move forward slowly until on limit",^b
~a=^a;SP~a=axhmspd[^a];PR~a=^b;BG~a
#CALENA2;WT 50;~a=^a;JP#CALENA2, (_LR~a=1);ST~a;MC~a
'If negative movement is allowed then the switch failed 
'  or we managed to overshoot twice it either way this is a fail
~a=^a;IF(_LR~a=1);^h=ELIMOST;'MG "STILL NOT ON LIMIT, fail";ENDIF
ENDIF
'If all is well
IF(^h=ENONE)
'Get number of steps to position near limit and use it
'  to estimate steps needed to move totally off the negative limit
'MG "wait"
JS#WAITAMF(^a);^b=encnlim[^a]-analogp[^a];JS#ENC2STP(^a,^b);^b=1.1*_JS
'Move off limit slowly and stop
'MG "Move off limit slowly",^b
~a=^a;PR~a=^b;BG~a
#CALENA3;WT 50;~a=^a;JP#CALENA3, ((_LR~a=0) & (_SC~a=0));ST~a;MC~a
'If we didn't get off the limit, fail
~a=^a;IF(_LR~a=0);^h=ELIMSWF
'MG "STILL ON LIMIT, fail"
ENDIF
ENDIF
ENDIF
'If success, make this the reference position
IF (^h=ENONE)
'MG "Calibrated axis",^a
JS#ZERSTP(^a);axiscal[^a]=true;ldelta[^a]=10*bcklsh[^a]
ELSE
'MG "Failed to calibrate axis",^a
~a=^a;MC~a;~a=^a;MO~a
ENDIF
ENDIF
axiserr[^a]=^h;'Store status
EN,,^h


'***************************************************************************
' Fancy MoVe(axis, position)
' Start a move to position on the specified axis, accounting for
'  both minimum incremental motion & backlash
'***************************************************************************
#FANCYMV;'(axis,absolute)
'Compute delta
^b=@RND[^b]
~a=^a;^c=^b-_TD~a
IF(^c<>0)
REM ~a=^a;MG "FANCYMV: Move axis",^a," from",_TD~a," to",^b
'If required move is too small
IF(@ABS[^c]<mininc[^a])
'MG "FANCYMV: Move is less than the minimum increment of",mininc[^a]
'First move mininc[^a]+@ABS[^c] in direction we last headed
IF(ldelta[^a]>0);~a=^a;^d=_TD~a+mininc[^a]+@ABS[^c]
ELSE;~a=^a;^d=_TD~a-mininc[^a]-@ABS[^c];ENDIF
~a=^a;AC~a=axaccel[^a];DC~a=axdecel[^a];SP~a=axlmspd[^a];PA~a=^d;SH~a;BG~a
~a=^a;MC~a
'Check position to see if we didn't reach our goal (i.e. we hit a limit)
~a=^a;IF(_TD~a<>^d)
'Figure how far we need to move in the other direction
IF(ldelta[^a]>0);~a=^a;^d=_TD~a-(2*(mininc[^a]+@ABS[^c]))
ELSE;~a=^a;^d=_TD~a+(2*(mininc[^a]+@ABS[^c]));ENDIF
'Compute delta
~a=^a;^e=^d-_TD~a
'Handle backlash
JS#BACKLSH(^a,^e)
'Move past in the other direction
~a=^a;AC~a=axaccel[^a];DC~a=axdecel[^a];SP~a=axlmspd[^a];PA~a=^d;SH~a;BG~a
~a=^a;MC~a
ENDIF
'Recompute delta
~a=^a;^c=^b-_TD~a
ENDIF
'Handle backlash
JS#BACKLSH(^a,^c)
'Start move to position
~a=^a;AC~a=axaccel[^a];DC~a=axdecel[^a];SP~a=axspd[^a]
'NB setting TW to value larger than max is ok
~a=^a;PA~a=^b;SH~a
~a=^a;TW~a=(@ABS[(1100*((^b-_TD~a)/_SP~a))]+100);BG~a
REM ~a=^a;MG "TW=",_TW~a
ENDIF
EN 1


'***************************************************************************
' Move to limit (axis, acceleration, deceleration, velocity)
' If limit doesn't engage sends ELIMSWF
' velocity must not be 0
' Intended for uncalibrated use
'***************************************************************************
#MOV2LIM
REM These first two lines are problematic for the FLSIN & FESIM,
REM  if it becomes necessary to enable them
REM At present only the GES is physically capable of overshooting its limits
REM  If we didn't last stop because of the opposite limit
REM   move away from the limit we want be just a bit so account for having 
REM   potentially overshot it.
REM IF(^d>0);^e=-axlmos[^a];^f=3;ELSE;^e=axlmos[^a];^f=2;ENDIF;
REM ~a=^a;AC~a=^b; DC~a=^c;IF(_SC~a<>^f);PR~a=^e; BG~a;MC~a;ENDIF;

^h=ENONE;'Hope success
'If we are at the limit then we are done!
~a=^a;^f=(((_LR~a<>0)|(^d>0))&((_LF~a<>0)|(^d<0)))
REM ~a=^a;'MG ^a,^f,^d,_LR~a,_LF~a
IF(^f)
' when calibrated, we could tighten the move distance estimate
^e=(axmaxp[^a]-axminp[^a])*1.1
'Begin move (-limit if neg, +lim if pos) wait until limit or timeout
~a=^a;AC~a=^b;DC~a=^c;SP~a=^d;IF(^d>0);PR~a=^e;ELSE;PR~a=-^e;ENDIF;SH~a;BG~a
'Wait until we stop moving
#MOV2LI1;WT 100;~a=^a;JP#MOV2LI1, (_SC~a = 0);~a=^a;MC~a
'Determine the expected stop code & lest the last delta
IF(^d>0);ldelta[^a]=^e;^f=2;ELSE;ldelta[^a]=-^e;^f=3;ENDIF
'If the stop code is not that for the expected limit switch we failed
~a=^a;IF (_SC~a<>^f);MO~a;^h=ELIMSWF;ENDIF
ENDIF
axiserr[^a]=^h;'Store status
EN ,,^h


'***************************************************************************
' Direction Change Query (Axis,position delta/direction)
'***************************************************************************
#DIRCNGQ
EN,,(((ldelta[^a]<0)&(^b>0)) | ((ldelta[^a]>0)&(^b<0)))


'***************************************************************************
' Back LaSH correction(axis, position delta)
' Routine applies a backlash correction if direction change
'***************************************************************************
#BACKLSH
'Figure out if a change in direction
JS#DIRCNGQ(^a,^b)
IF(_JS=true)
'Correct for backlash by simply changing the current position
~a=^a;IF(^b>0);^c=_TD~a-bcklsh[^a];ELSE;^c=_TD~a+bcklsh[^a];ENDIF
JS#DPWAFE(^a,^c)
ENDIF
ldelta[^a]=^b
EN


'***************************************************************************
' Check Sanity(axis, position)
'  Return true if position is, potentially, physically realizeable.
'  False otherwise 
'***************************************************************************
#SANEPOS
EN,,((^b>=axminp[^a]) & (^b<=axmaxp[^a]))


'***************************************************************************
' ANAlog Moving Average Filter
' Locals:
'   ^a=index counter
'   ^b=filter size
'   ^c=filter size -1
'   ^d=running total for GES
'   ^e=running total for FESEL
'   ^f=running total for FOC
' Arrays:
'   gespacu, felpacu, focpacu Accumulator arrays for the average
' Output (GLOBAL):
'   gesanap  filtered GES position
'   felanap  filtered FESEL position
'   focanap  filtered FOC position
'   analogp[8]  filter analog positions for each axis, only the GES,FESEL, &
'            FOC axes are meaningful
'***************************************************************************
#ANAMAF
JS#ZS;IF (_JS<1);JS#ANAMAF
ELSE
^b=ANAMAFSZ;^c=^b-1
~a=GESAX;gesanap=_TP~a
~a=FESELAX;felanap=_TP~a
~a=FOCAX;focanap=_TP~a
^d=gesanap*^c;^e=felanap*^c;^f=focanap*^c
DA gespacu[0], felpacu[0], focpacu[0]
DM gespacu[^b], felpacu[^b], focpacu[^b]
REM Initialize array with analog encoder values
^a=0
#ANAMAF1
~a=GESAX;gespacu[^a]=_TP~a
~a=FESELAX;felpacu[^a]=_TP~a
~a=FOCAX;focpacu[^a]=_TP~a
^a=^a+1
JP#ANAMAF1,^a<^b
'#ANAMAF2 is the filter.  It takes the most recent reading,
'  tosses out the oldest reading, sums the values and takes an average.
^a=0;AT0
#ANAMAF2
'If axis is in motion, update the index of the most recent dirty value
~a=GESAX;IF(_TS~a & $80);anapcln[GESAX]=^a;ENDIF
~a=FOCAX;IF(_TS~a & $80);anapcln[FOCAX]=^a;ENDIF
~a=FESELAX;IF(_TS~a & $80);anapcln[FESELAX]=^a;ENDIF
'Current value
~a=GESAX;gespacu[^a]=_TP~a
~a=FESELAX;felpacu[^a]=_TP~a
~a=FOCAX;focpacu[^a]=_TP~a
'sum in current value and subtract oldest value
^g=^a+1
^d=^d-gespacu[^g]+gespacu[^a]
^e=^e-felpacu[^g]+felpacu[^a]
^f=^f-focpacu[^g]+focpacu[^a]
'Store filtered readings
gesanap=^d/^c;felanap=^e/^c;focanap=^f/^c
analogp[GESAX]=gesanap;analogp[FESELAX]=felanap;analogp[FOCAX]=focanap
^a=^g
'See if the reading is clear of motion contamination
IF(anapcln[GESAX]=^a);anapcln[GESAX]=-1;ENDIF
IF(anapcln[FESELAX]=^a);anapcln[FESELAX]=-1;ENDIF
IF(anapcln[FOCAX]=^a);anapcln[FOCAX]=-1;ENDIF
'If last read then subtract first array element and reset ^a
'MG TIME-^g
AT-1;JP#ANAMAF2,^a<^c
'If axis is in motion, update the index of the most recent dirty value
~a=GESAX;IF(_TS~a & $80);anapcln[GESAX]=^a;ENDIF
~a=FOCAX;IF(_TS~a & $80);anapcln[FOCAX]=^a;ENDIF
~a=FESELAX;IF(_TS~a & $80);anapcln[FESELAX]=^a;ENDIF
'Current value
~a=GESAX;gespacu[^a]=_TP~a
~a=FESELAX;felpacu[^a]=_TP~a
~a=FOCAX;focpacu[^a]=_TP~a;
'sum in current value and subract oldest value
^d=^d-gespacu[0]+gespacu[^a]
^e=^e-felpacu[0]+felpacu[^a]
^f=^f-focpacu[0]+focpacu[^a]
'Store filtered readings
gesanap=^d/^c;felanap=^e/^c;focanap=^f/^c
analogp[GESAX]=gesanap;analogp[FESELAX]=felanap;analogp[FOCAX]=focanap
^a=0
'See if the reading is clear of motion contamination
IF(anapcln[GESAX]=^a);anapcln[GESAX]=-1;ENDIF
IF(anapcln[FESELAX]=^a);anapcln[FESELAX]=-1;ENDIF
IF(anapcln[FOCAX]=^a);anapcln[FOCAX]=-1;ENDIF
'MG TIME-^h,gesanap,felanap,focanap
AT-1;JP#ANAMAF2
ENDIF
EN


'***************************************************************************
' WAITAMF(axis) Wait for the analog moving average filter to refresh for
'  the specified axis
'***************************************************************************
#WAITAMF
IF (anapcln[^a]<>-1)
REM MG "Waiting...";^b=TIME
#WAITAM1;WT200;JP#WAITAM1,(anapcln[^a]<>-1)
REM ^c=TIME-^b;MG ^c," ms."
ENDIF
EN


'***************************************************************************
' ZERO ARRay
' Zeros the contents of the array
'***************************************************************************
#ZEROARR;^b=^a[-1];^c=0
#ZEROAR1;^a[^c]=0;^c=^c+1;JP#ZEROAR1,(^c<^b);EN


'***************************************************************************
' Mean of an ARRay
'***************************************************************************
#MEANARR
^b=^a[-1];^c=0;^d=0
#MEANAR1;^d=^d+^a[^c];^c=^c+1;JP#MEANAR1,(^c<^b)
EN,,^d/^b


'***************************************************************************
' Standard Deviation of an array, must pass mean as arg 2
'***************************************************************************
#STDDEV
^c=^a[-1];^d=0;^e=0
#STDDEV1;^g=^a[^d]-^b;^e=^e+(^g*^g);^d=^d+1;JP#STDDEV1,(^d<^c)
EN,,@SQR[^e/^c]


'***************************************************************************
' Tell Switch status
'***************************************************************************
#TELLTS;
'Stack and XQ fancy footwork
JS#ZS;IF (_JS<1);ed4=_ED4;JS#TELLTS(a[ed4]);ret[ed4]=ENONE;ELSE
~a=^a;^b=_TS~a;MG "Axis ",~a
IF (^b & $80);MG "In motion";ELSE;MG "Stopped";ENDIF
IF (^b & $40);MG "Axis error exceeds error limit";ENDIF
IF (^b & $20);MG "Motor Off";ELSE;MG "Motor On";ENDIF
IF (^b & $08);NO;ELSE;MG "Forward Limit Tripped";ENDIF
IF (^b & $04);NO;ELSE;MG "Reverse Limit Tripped";ENDIF
IF (^b & $02);MG "Home 1";ELSE;MG "Home 0";ENDIF
IF (^b & $01);MG "Axis Latched";ENDIF
~a=^a;IF (@IN[~a-60]) ;MG "Axis Abort 1";ELSE;MG "Axis Abort 0";ENDIF
ENDIF
EN


'***************************************************************************
' ZERo STePper counts(axis)
'   Zeros the stepper counts for axis, at current position, 
'  regardless of analog feedback status, preserves AF
' Define Position With Analog Feedback Enabled(axis,position)
'***************************************************************************
#ZERSTP;^b=0
#DPWAFE
~a=^a;^g=_AF~a;AF~a=0
IF(^a=GESAX);~a=^a;DP~a=^b;rstpm[GESPM]=1
ELSE;IF(^a=FESELAX);~a=^a;DP~a=^b;rstpm[FESELPM]=1
ELSE;~a=^a;DP~a=^b;ENDIF;ENDIF
~a=^a;AF~a=^g;
EN


'***************************************************************************
' ENCoder counts to STePs(axis, counts) 
'***************************************************************************
#ENC2STP
'MG "Counts: ",^b
~a=^a;^h=(^b*_YA~a*_YB~a)/_YC~a
'MG "To Steps: ",^h
EN,,^h


'***************************************************************************
' STePs to ENCoder counts(axis, steps) 
'***************************************************************************
#STP2ENC
~a=^a;^h=(^b*_YC~a)/(_YA~a*_YB~a)
EN,,^h


'***************************************************************************
' MOVTIME(dist,speed,accel,decel)
' Compute the time travel would theoretically take in units of the RTC
'***************************************************************************
#MOVTIME
REM a=^a;b=^b;c=^c;d=^d
REM MG "Move Time:",^a,^b,^c,^d
EN,,(@ABS[^a/^b]+(0.5*@ABS[(^b/^c)+(^b/^d)]))*(1000000/_TM)


'***************************************************************************
' Lock Monitor
' Monitors the axis locks for the HiRes stage
'***************************************************************************
#LOCKMON
IF(@AN[7] > LCKVOLT);HRTLTLK=true;ELSE;HRTLTLK=false;ENDIF
IF(@AN[8] > LCKVOLT);HRAZLK=true;ELSE;HRAZLK=false;ENDIF
WT 1000;JP#LOCKMON
EN


'***************************************************************************
' POTentiometer MONitor(axis)
' Check to see if the steps changed more (within reason) than the pot 
'  did every 100 ms
'   If so then Halt motion as the pot may be jammed
'   when a monitored axis has its steps reset one must also set
'   rstpm[GESPM]=true or rstpm[FESELPM]=true 
'  ^a=axis ^b=oldpot ^c=oldstep ^d=newpot  ^e=newstep
'  ^f=disagreement in pot v steps
'  ^h=delta pot ^g=delta step 
'***************************************************************************
#POTMON
AT0;
~a=^a;^b=_TP~a; ^c=_TD~a
#POTCHK1
IF((rstpm[GESPM]=true)&(^a=GESAX))
 ~a=^a;^c=0;^e=0;^b=_TP~a;^d=_TP~a;rstpm[GESPM]=false;' Reset old and new
ENDIF
IF((rstpm[FESELPM]=true)&(^a=FESELAX))
 ~a=^a;^c=0;^e=0;^b=_TP~a;^d=_TP~a;rstpm[GESPM]=false;' Reset old and new
ENDIF
~a=^a;^d=_TP~a; ^e=_TD~a
^h=^d  - ^b
^g=^e - ^c
^c=^e; ^b=^d
~a=^a;^f=@ABS[^h*(_YB*_YA~a)/_YC~a-^g]
~a=^a;IF(^f>error);DC~a=axdecel[^a];ST~a;MC~a;~a=^a;MO~a;potStat[^a]=potjam
JS#ERRMSG(^a,EPOTJAM,dpot,dstep,error)
ENDIF;
AT-250;JP #POTCHK1;'        Check again in a few ms
EN


'***************************************************************************
' ERRor MeSsaGe(axis, error,...)
'  Reports the specified error
'***************************************************************************
#ERRMSG
IF (^a=GESAX)
IF (^b=ENONE);MG "OK"
ELSE;IF (^b=EPOTJAM);MG "!GES:ERRPot not changing with steps."
ELSE;IF (^b=ELIMSWF);MG "!GES:ERRLimit switch failure."
ELSE;IF (^b=EGESPMM)
MG "!GES:ERREncoder & stepper mismatch. Try recalibrating.",gesanap,_TDA
ELSE;IF (^b=EFAIL);MG "!GES:ERRUnspecified error."
ELSE;IF (^b=ECRAZY);MG "!GES:ERRRequested value out of allowed range."
ELSE;IF (^b=ELIMOST);MG "!GES:ERROvershot limit switch."
ELSE;MG "!GES:ERRUnknown error code",^b,". This is a software bug."
ENDIF;ENDIF;ENDIF;ENDIF;ENDIF;ENDIF;ENDIF
ENDIF
IF (^a=HRTLTAX)
IF (^b=ENONE);MG "OK"
ELSE;IF (^b=EHMERR);MG "!HRTLT:ERRHoming failure. Switch did not toggle."
ELSE;IF (^b=ELIMSWF);MG "!HRTLT:ERRLimit switch failure."
ELSE;IF (^b=ELCKERR);MG "!HRTLT:ERRLocked. You must loosen the locking nut."
ELSE;IF (^b=ECRAZY);MG "!HRTLT:ERRRequested value out of allowed range."
ELSE;IF (^b=EFAIL);MG "!HRTLT:ERRUnspecified error."
ELSE;MG "!HRTLT:ERRUnknown error code",^b,". This is a software bug."
ENDIF;ENDIF;ENDIF;ENDIF;ENDIF;ENDIF
ENDIF
IF (^a=HRAZAX)
IF (^b=ENONE);MG "OK"
ELSE;IF (^b=EHMERR);MG "!HRAZ:ERRHoming failure. Switch did not toggle."
ELSE;IF (^b=ELIMSWF);MG "!HRAZ:ERRLimit switch failure."
ELSE;IF (^b=ELCKERR);MG "!HRAZ:ERRLocked. You must loosen the locking nut."
ELSE;IF (^b=ECRAZY);MG "!HRAZ:ERRRequested value out of allowed range."
ELSE;IF (^b=EFAIL);MG "!HRAZ:ERRUnspecified error."
ELSE;MG "!HRAZ: Unknown error code",^b,". This is a software bug."
ENDIF;ENDIF;ENDIF;ENDIF;ENDIF;ENDIF
ENDIF
IF (^a=LRTLTAX)
IF (^b=ENONE);MG "OK"
ELSE;IF (^b=EHMERR);MG "!LRTLT:ERRHoming failure. Switch did not toggle."
ELSE;IF (^b=ECRAZY);MG "!LRTLT:ERRRequested value out of allowed range."
ELSE;IF (^b=EFAIL);MG "!LRTLT:ERRUnspecified error."
ELSE;MG "!LRTLT:ERRUnknown error code",^b,". This is a software bug."
ENDIF;ENDIF;ENDIF;ENDIF
ENDIF
IF (^a=FOCAX)
IF (^b=ENONE);MG "OK"
ELSE;IF (^b=ECRAZY);MG "!FOC:ERRRequested value out of allowed range."
ELSE;IF (^b=EFAIL);MG "!FOC:ERRUnspecified error."
ELSE;MG "!FOC:ERRUnknown error code",^b,". This is a software bug."
ENDIF;ENDIF;ENDIF
ENDIF
IF (^a=FLSINAX)
IF (^b=ENONE);MG "OK"
ELSE;IF (^b=ELIMSWF);MG "!FLSIN:ERRLimit switch failure."
ELSE;IF (^b=EHMERR);MG "!FLSIN:ERRHoming failure. Switch did not toggle."
ELSE;IF (^b=ECRAZY);MG "!FLSIN:ERRRequested value out of allowed range."
ELSE;IF (^b=EFAIL);MG "!FLSIN:ERRUnspecified error."
ELSE;MG "!FLSIN:ERRUnknown error code",^b,". This is a software bug."
ENDIF;ENDIF;ENDIF;ENDIF;ENDIF
ENDIF
IF (^a=FESINAX)
IF (^b=ENONE);MG "OK"
ELSE;IF (^b=ELIMSWF);MG "!FESIN:ERRLimit switch failure."
ELSE;IF (^b=EHMERR);MG "!FESIN:ERRHoming failure. Switch did not toggle."
ELSE;IF (^b=ECRAZY);MG "!FESIN:ERRRequested value out of allowed range."
ELSE;IF (^b=EFAIL);MG "!FESIN:ERRUnspecified error."
ELSE;MG "!FESIN:ERRUnknown error code",^b,". This is a software bug."
ENDIF;ENDIF;ENDIF;ENDIF;ENDIF
ENDIF
IF (^a=FESELAX)
IF (^b=ENONE);MG "OK"
ELSE;IF (^b=EPOTJAM);MG "!FESEL: ERRPot not changing with steps."
ELSE;IF (^b=ELIMSWF);MG "!FESEL:ERR Limit switch failure."
ELSE;IF (^b=EHMERR);MG "!FESEL: ERRHoming failure. Switch did not toggle."
ELSE;IF (^b=EBADFP)
MG "!FESEL: ERR",^c {Z2.0}," is not a valid filter position."
ELSE;IF (^b=ECRAZY);MG "!FESEL: ERRRequested value out of allowed range."
ELSE;IF (^b=EFAIL);MG "!FESEL: ERRUnspecified error."
ELSE;IF (^b=EFLTUNSF);MG "!FESEL:ERRFilter changer unsafe state. Fix Manually."
ELSE;MG "!FESEL:ERRUnknown error code",^b,". This is a software bug."
ENDIF;ENDIF;ENDIF;ENDIF;ENDIF;ENDIF;ENDIF;ENDIF
ENDIF
axiserr[^a]=ENONE
EN


'***************************************************************************
' Tell Amplifier status
'***************************************************************************
#TELLTA
^a=_TA0
IF (^a & $10);MG "Over Current (E-H Axes)";ENDIF
IF (^a & $1);MG "Over Current (A-D Axes)";ENDIF
^a=_TA3
IF (^a & $2);MG "ELO Active (E-H Axes)";ENDIF
IF (^a & $1);MG "ELO Active (A-D Axes)";ENDIF
EN


'***************************************************************************
' Command Error Interrupt
' Routine executed whenever a program error occurs
'***************************************************************************
#CMDERR
MG "#Threads active:",_HX0,_HX1,_HX2,_HX3,_HX4,_HX5,_HX6,_HX7
MG "#!CMDERR (thread",_ED1," line",_ED,"):";TC1
EN


#RUNNIN;MG "Active Threads",_HX0,_HX1,_HX2,_HX3,_HX4,_HX5,_HX6,_HX7;EN


'***************************************************************************
' ZS
' Returns the stack level of the calling subtoutine
'***************************************************************************
#ZS
IF(_ED4=0);zs=_ZS0;ENDIF
IF(_ED4=1);zs=_ZS1;ENDIF
IF(_ED4=2);zs=_ZS2;ENDIF
IF(_ED4=3);zs=_ZS3;ENDIF
IF(_ED4=4);zs=_ZS4;ENDIF
IF(_ED4=5);zs=_ZS5;ENDIF
IF(_ED4=6);zs=_ZS6;ENDIF
IF(_ED4=7);zs=_ZS7;ENDIF
EN,,zs-1
